# **********************************************************************
#
# Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.5.1
#
# <auto-generated>
#
# Generated from file `Connection.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy
import Ice_ObjectAdapterF_ice
import Ice_Identity_ice
import Ice_Endpoint_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Start of module Ice
__name__ = 'Ice'

if 'ConnectionInfo' not in _M_Ice.__dict__:
    _M_Ice.ConnectionInfo = Ice.createTempClass()
    class ConnectionInfo(object):
        '''Base class providing access to the connection details.'''
        def __init__(self, incoming=False, adapterName='', connectionId=''):
            self.incoming = incoming
            self.adapterName = adapterName
            self.connectionId = connectionId

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_ConnectionInfo)

        __repr__ = __str__

    _M_Ice._t_ConnectionInfo = IcePy.defineClass('::Ice::ConnectionInfo', ConnectionInfo, -1, (), False, False, None, (), (
        ('incoming', (), IcePy._t_bool, False, 0),
        ('adapterName', (), IcePy._t_string, False, 0),
        ('connectionId', (), IcePy._t_string, False, 0)
    ))
    ConnectionInfo._ice_type = _M_Ice._t_ConnectionInfo

    _M_Ice.ConnectionInfo = ConnectionInfo
    del ConnectionInfo

if 'Connection' not in _M_Ice.__dict__:
    _M_Ice.Connection = Ice.createTempClass()
    class Connection(object):
        '''The user-level interface to a connection.'''
        def __init__(self):
            if Ice.getType(self) == _M_Ice.Connection:
                raise RuntimeError('Ice.Connection is an abstract class')

        def close(self, force):
            '''Close a connection, either gracefully or forcefully. If a
connection is closed forcefully, it closes immediately, without
sending the relevant close connection protocol messages to the
peer and waiting for the peer to acknowledge these protocol
messages.

Arguments:
    force If true, close forcefully. Otherwise the
connection is closed gracefully.'''
            pass

        def createProxy(self, id):
            '''Create a special proxy that always uses this connection. This
can be used for callbacks from a server to a client if the
server cannot directly establish a connection to the client,
for example because of firewalls. In this case, the server
would create a proxy using an already established connection
from the client.

Arguments:
    id The identity for which a proxy is to be created.

Returns:
    A proxy that matches the given identity and uses this
connection.'''
            pass

        def setAdapter(self, adapter):
            '''Explicitly set an object adapter that dispatches requests that
are received over this connection. A client can invoke an
operation on a server using a proxy, and then set an object
adapter for the outgoing connection that is used by the proxy
in order to receive callbacks. This is useful if the server
cannot establish a connection back to the client, for example
because of firewalls.

Arguments:
    adapter The object adapter that should be used by this
connection to dispatch requests. The object adapter must be
activated. When the object adapter is deactivated, it is
automatically removed from the connection.'''
            pass

        def getAdapter(self):
            '''Get the object adapter that dispatches requests for this
connection.

Returns:
    The object adapter that dispatches requests for the
connection, or null if no adapter is set.'''
            pass

        def getEndpoint(self):
            '''Get the endpoint from which the connection was created.

Returns:
    The endpoint from which the connection was created.'''
            pass

        def flushBatchRequests(self):
            '''Flush any pending batch requests for this connection. This
causes all batch requests that were sent via proxies that use
this connection to be sent to the server.'''
            pass

        def type(self):
            '''Return the connection type. This corresponds to the endpoint
type, i.e., "tcp", "udp", etc.

Returns:
    The type of the connection.'''
            pass

        def timeout(self):
            '''Get the timeout for the connection.

Returns:
    The connection's timeout.'''
            pass

        def toString(self):
            '''Return a description of the connection as human readable text,
suitable for logging or error messages.

Returns:
    The description of the connection as human readable
text.'''
            pass

        def getInfo(self):
            '''Returns the connection information.

Returns:
    The connection information.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_Connection)

        __repr__ = __str__

    _M_Ice._t_Connection = IcePy.defineClass('::Ice::Connection', Connection, -1, (), True, False, None, (), ())
    Connection._ice_type = _M_Ice._t_Connection

    _M_Ice.Connection = Connection
    del Connection

if 'IPConnectionInfo' not in _M_Ice.__dict__:
    _M_Ice.IPConnectionInfo = Ice.createTempClass()
    class IPConnectionInfo(_M_Ice.ConnectionInfo):
        '''Provides access to the connection details of an IP connection'''
        def __init__(self, incoming=False, adapterName='', connectionId='', localAddress="", localPort=-1, remoteAddress="", remotePort=-1):
            _M_Ice.ConnectionInfo.__init__(self, incoming, adapterName, connectionId)
            self.localAddress = localAddress
            self.localPort = localPort
            self.remoteAddress = remoteAddress
            self.remotePort = remotePort

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_IPConnectionInfo)

        __repr__ = __str__

    _M_Ice._t_IPConnectionInfo = IcePy.defineClass('::Ice::IPConnectionInfo', IPConnectionInfo, -1, (), False, False, _M_Ice._t_ConnectionInfo, (), (
        ('localAddress', (), IcePy._t_string, False, 0),
        ('localPort', (), IcePy._t_int, False, 0),
        ('remoteAddress', (), IcePy._t_string, False, 0),
        ('remotePort', (), IcePy._t_int, False, 0)
    ))
    IPConnectionInfo._ice_type = _M_Ice._t_IPConnectionInfo

    _M_Ice.IPConnectionInfo = IPConnectionInfo
    del IPConnectionInfo

if 'TCPConnectionInfo' not in _M_Ice.__dict__:
    _M_Ice.TCPConnectionInfo = Ice.createTempClass()
    class TCPConnectionInfo(_M_Ice.IPConnectionInfo):
        '''Provides access to the connection details of a TCP connection'''
        def __init__(self, incoming=False, adapterName='', connectionId='', localAddress="", localPort=-1, remoteAddress="", remotePort=-1):
            _M_Ice.IPConnectionInfo.__init__(self, incoming, adapterName, connectionId, localAddress, localPort, remoteAddress, remotePort)

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_TCPConnectionInfo)

        __repr__ = __str__

    _M_Ice._t_TCPConnectionInfo = IcePy.defineClass('::Ice::TCPConnectionInfo', TCPConnectionInfo, -1, (), False, False, _M_Ice._t_IPConnectionInfo, (), ())
    TCPConnectionInfo._ice_type = _M_Ice._t_TCPConnectionInfo

    _M_Ice.TCPConnectionInfo = TCPConnectionInfo
    del TCPConnectionInfo

if 'UDPConnectionInfo' not in _M_Ice.__dict__:
    _M_Ice.UDPConnectionInfo = Ice.createTempClass()
    class UDPConnectionInfo(_M_Ice.IPConnectionInfo):
        '''Provides access to the connection details of a UDP connection'''
        def __init__(self, incoming=False, adapterName='', connectionId='', localAddress="", localPort=-1, remoteAddress="", remotePort=-1, mcastAddress='', mcastPort=-1):
            _M_Ice.IPConnectionInfo.__init__(self, incoming, adapterName, connectionId, localAddress, localPort, remoteAddress, remotePort)
            self.mcastAddress = mcastAddress
            self.mcastPort = mcastPort

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_UDPConnectionInfo)

        __repr__ = __str__

    _M_Ice._t_UDPConnectionInfo = IcePy.defineClass('::Ice::UDPConnectionInfo', UDPConnectionInfo, -1, (), False, False, _M_Ice._t_IPConnectionInfo, (), (
        ('mcastAddress', (), IcePy._t_string, False, 0),
        ('mcastPort', (), IcePy._t_int, False, 0)
    ))
    UDPConnectionInfo._ice_type = _M_Ice._t_UDPConnectionInfo

    _M_Ice.UDPConnectionInfo = UDPConnectionInfo
    del UDPConnectionInfo

# End of module Ice
