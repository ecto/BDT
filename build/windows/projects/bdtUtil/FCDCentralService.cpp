// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `FCDCentralService.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <FCDCentralService.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/DisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __iBS__ProxyCentralService__RegisterByCallerAdress_name = "RegisterByCallerAdress";

const ::std::string __iBS__ProxyCentralService__RegisterByProxyStr_name = "RegisterByProxyStr";

const ::std::string __iBS__ProxyCentralService__UnRegister_name = "UnRegister";

const ::std::string __iBS__ProxyCentralService__UnRegisterAll_name = "UnRegisterAll";

const ::std::string __iBS__ProxyCentralService__ListAll_name = "ListAll";

const ::std::string __iBS__FcdcReadService__GetFeatureDomains_name = "GetFeatureDomains";

const ::std::string __iBS__FcdcReadService__GetFeatureObservers_name = "GetFeatureObservers";

const ::std::string __iBS__FcdcReadService__GetDoublesColumnVector_name = "GetDoublesColumnVector";

const ::std::string __iBS__FcdcReadService__GetIntsColumnVector_name = "GetIntsColumnVector";

const ::std::string __iBS__FcdcReadService__GetDoublesRowMatrix_name = "GetDoublesRowMatrix";

const ::std::string __iBS__FcdcReadService__GetObserverStats_name = "GetObserverStats";

const ::std::string __iBS__FcdcReadService__GetObserversStats_name = "GetObserversStats";

const ::std::string __iBS__FcdcReadService__GetRowMatrix_name = "GetRowMatrix";

const ::std::string __iBS__FcdcReadService__SampleRowMatrix_name = "SampleRowMatrix";

const ::std::string __iBS__FcdcReadService__GetObserverIndex_name = "GetObserverIndex";

const ::std::string __iBS__FcdcReadService__GetFeatureIdxsByIntKeys_name = "GetFeatureIdxsByIntKeys";

const ::std::string __iBS__FcdcReadService__GetFeatureCntsByIntKeys_name = "GetFeatureCntsByIntKeys";

const ::std::string __iBS__FcdcReadService__GetAMDTaskInfo_name = "GetAMDTaskInfo";

const ::std::string __iBS__FcdcReadService__GetFeatureValueStoreDir_name = "GetFeatureValueStoreDir";

const ::std::string __iBS__FcdcReadService__GetFeatureValuePathPrefix_name = "GetFeatureValuePathPrefix";

const ::std::string __iBS__FcdcReadWriteService__SetFeatureDomains_name = "SetFeatureDomains";

const ::std::string __iBS__FcdcReadWriteService__SetFeatureObservers_name = "SetFeatureObservers";

const ::std::string __iBS__FcdcReadWriteService__SetDoublesColumnVector_name = "SetDoublesColumnVector";

const ::std::string __iBS__FcdcReadWriteService__SetBytesColumnVector_name = "SetBytesColumnVector";

const ::std::string __iBS__FcdcReadWriteService__SetIntsColumnVector_name = "SetIntsColumnVector";

const ::std::string __iBS__FcdcReadWriteService__SetDoublesRowMatrix_name = "SetDoublesRowMatrix";

const ::std::string __iBS__FcdcAdminService__Shutdown_name = "Shutdown";

const ::std::string __iBS__FcdcAdminService__RqstNewFeatureDomainID_name = "RqstNewFeatureDomainID";

const ::std::string __iBS__FcdcAdminService__RqstNewFeatureObserverID_name = "RqstNewFeatureObserverID";

const ::std::string __iBS__FcdcAdminService__RqstNewFeatureObserversInGroup_name = "RqstNewFeatureObserversInGroup";

const ::std::string __iBS__FcdcAdminService__AttachBigMatrix_name = "AttachBigMatrix";

const ::std::string __iBS__FcdcAdminService__AttachBigVector_name = "AttachBigVector";

const ::std::string __iBS__FcdcAdminService__ForceLoadInRAM_name = "ForceLoadInRAM";

const ::std::string __iBS__FcdcAdminService__ForceLeaveRAM_name = "ForceLeaveRAM";

const ::std::string __iBS__FcdcAdminService__RecalculateObserverStats_name = "RecalculateObserverStats";

const ::std::string __iBS__FcdcAdminService__RecalculateObserverIndex_name = "RecalculateObserverIndex";

const ::std::string __iBS__FcdcAdminService__RemoveFeatureObservers_name = "RemoveFeatureObservers";

const ::std::string __iBS__FcdcAdminService__SetObserverStats_name = "SetObserverStats";

const ::std::string __iBS__FcdcRUVService__SetActiveK_name = "SetActiveK";

const ::std::string __iBS__FcdcRUVService__SetOutputMode_name = "SetOutputMode";

const ::std::string __iBS__FcdcRUVService__SetOutputSamples_name = "SetOutputSamples";

const ::std::string __iBS__FcdcRUVService__ExcludeSamplesForGroupMean_name = "ExcludeSamplesForGroupMean";

const ::std::string __iBS__FcdcRUVService__SetOutputScale_name = "SetOutputScale";

const ::std::string __iBS__FcdcRUVService__SetOutputWorkerNum_name = "SetOutputWorkerNum";

const ::std::string __iBS__FcdcRUVService__SetCtrlQuantileValues_name = "SetCtrlQuantileValues";

const ::std::string __iBS__FcdcRUVService__RebuildRUVModel_name = "RebuildRUVModel";

const ::std::string __iBS__FcdcRUVService__GetConditionIdxs_name = "GetConditionIdxs";

const ::std::string __iBS__FcdcRUVService__GetConditionInfos_name = "GetConditionInfos";

const ::std::string __iBS__FcdcRUVService__GetSamplesInGroups_name = "GetSamplesInGroups";

const ::std::string __iBS__FcdcRUVService__GetG_name = "GetG";

const ::std::string __iBS__FcdcRUVService__GetWt_name = "GetWt";

const ::std::string __iBS__FcdcRUVService__GetEigenVals_name = "GetEigenVals";

const ::std::string __iBS__FcdcRUVService__SelectKByEigenVals_name = "SelectKByEigenVals";

const ::std::string __iBS__FcdcRUVService__DecomposeVariance_name = "DecomposeVariance";

const ::std::string __iBS__FcdcRUVService__SetWtVectorIdxs_name = "SetWtVectorIdxs";

const ::std::string __iBS__BigMatrixService__SetOutputSamples_name = "SetOutputSamples";

const ::std::string __iBS__BigMatrixService__SetRowAdjust_name = "SetRowAdjust";

const ::std::string __iBS__BigMatrixService__RecalculateObserverStats_name = "RecalculateObserverStats";

const ::std::string __iBS__FcdcFacetAdminService__RqstNewRUVFacet_name = "RqstNewRUVFacet";

const ::std::string __iBS__FcdcFacetAdminService__RemoveRUVFacet_name = "RemoveRUVFacet";

const ::std::string __iBS__FcdcFacetAdminService__SetRUVFacetInfo_name = "SetRUVFacetInfo";

const ::std::string __iBS__FcdcFacetAdminService__GetRUVFacetInfo_name = "GetRUVFacetInfo";

const ::std::string __iBS__FcdcFacetAdminService__GetRUVFacet_name = "GetRUVFacet";

const ::std::string __iBS__FcdcFacetAdminService__GetBigMatrixFacet_name = "GetBigMatrixFacet";

}

namespace Ice
{
}

IceAsync::iBS::AMD_FcdcReadService_GetDoublesColumnVector::AMD_FcdcReadService_GetDoublesColumnVector(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcReadService_GetDoublesColumnVector::ice_response(::Ice::Int __ret, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& values)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(values);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcReadService_GetDoublesColumnVector::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcReadService_GetIntsColumnVector::AMD_FcdcReadService_GetIntsColumnVector(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcReadService_GetIntsColumnVector::ice_response(::Ice::Int __ret, const ::std::pair<const ::Ice::Int*, const ::Ice::Int*>& values)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(values);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcReadService_GetIntsColumnVector::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcReadService_GetDoublesRowMatrix::AMD_FcdcReadService_GetDoublesRowMatrix(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcReadService_GetDoublesRowMatrix::ice_response(::Ice::Int __ret, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& values)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(values);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcReadService_GetDoublesRowMatrix::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcReadService_GetRowMatrix::AMD_FcdcReadService_GetRowMatrix(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcReadService_GetRowMatrix::ice_response(::Ice::Int __ret, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& values)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(values);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcReadService_GetRowMatrix::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcReadService_SampleRowMatrix::AMD_FcdcReadService_SampleRowMatrix(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcReadService_SampleRowMatrix::ice_response(::Ice::Int __ret, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& values)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(values);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcReadService_SampleRowMatrix::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcReadService_GetFeatureIdxsByIntKeys::AMD_FcdcReadService_GetFeatureIdxsByIntKeys(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcReadService_GetFeatureIdxsByIntKeys::ice_response(::Ice::Int __ret, const ::std::pair<const ::Ice::Long*, const ::Ice::Long*>& featureIdxs)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(featureIdxs);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcReadService_GetFeatureIdxsByIntKeys::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcReadService_GetFeatureCntsByIntKeys::AMD_FcdcReadService_GetFeatureCntsByIntKeys(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcReadService_GetFeatureCntsByIntKeys::ice_response(::Ice::Int __ret, const ::std::pair<const ::Ice::Long*, const ::Ice::Long*>& featureCnts)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(featureCnts);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcReadService_GetFeatureCntsByIntKeys::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcReadWriteService_SetDoublesColumnVector::AMD_FcdcReadWriteService_SetDoublesColumnVector(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcReadWriteService_SetDoublesColumnVector::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcReadWriteService_SetDoublesColumnVector::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcReadWriteService_SetBytesColumnVector::AMD_FcdcReadWriteService_SetBytesColumnVector(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcReadWriteService_SetBytesColumnVector::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcReadWriteService_SetBytesColumnVector::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcReadWriteService_SetIntsColumnVector::AMD_FcdcReadWriteService_SetIntsColumnVector(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcReadWriteService_SetIntsColumnVector::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcReadWriteService_SetIntsColumnVector::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcReadWriteService_SetDoublesRowMatrix::AMD_FcdcReadWriteService_SetDoublesRowMatrix(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcReadWriteService_SetDoublesRowMatrix::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcReadWriteService_SetDoublesRowMatrix::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcAdminService_ForceLoadInRAM::AMD_FcdcAdminService_ForceLoadInRAM(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcAdminService_ForceLoadInRAM::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcAdminService_ForceLoadInRAM::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcAdminService_ForceLeaveRAM::AMD_FcdcAdminService_ForceLeaveRAM(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcAdminService_ForceLeaveRAM::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcAdminService_ForceLeaveRAM::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcAdminService_RecalculateObserverStats::AMD_FcdcAdminService_RecalculateObserverStats(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcAdminService_RecalculateObserverStats::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcAdminService_RecalculateObserverStats::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcAdminService_RecalculateObserverIndex::AMD_FcdcAdminService_RecalculateObserverIndex(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcAdminService_RecalculateObserverIndex::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcAdminService_RecalculateObserverIndex::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcAdminService_RemoveFeatureObservers::AMD_FcdcAdminService_RemoveFeatureObservers(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcAdminService_RemoveFeatureObservers::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcAdminService_RemoveFeatureObservers::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcRUVService_SetActiveK::AMD_FcdcRUVService_SetActiveK(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcRUVService_SetActiveK::ice_response(::Ice::Int __ret)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcRUVService_SetActiveK::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcRUVService_RebuildRUVModel::AMD_FcdcRUVService_RebuildRUVModel(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcRUVService_RebuildRUVModel::ice_response(::Ice::Int __ret, ::Ice::Long taskID)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(taskID);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcRUVService_RebuildRUVModel::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_FcdcRUVService_DecomposeVariance::AMD_FcdcRUVService_DecomposeVariance(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_FcdcRUVService_DecomposeVariance::ice_response(::Ice::Int __ret, const ::iBS::RUVVarDecomposeInfoVec& vds, ::Ice::Long taskID)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(vds);
            __os->write(taskID);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_FcdcRUVService_DecomposeVariance::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}

IceAsync::iBS::AMD_BigMatrixService_RecalculateObserverStats::AMD_BigMatrixService_RecalculateObserverStats(::IceInternal::Incoming& in) :
    ::IceInternal::IncomingAsync(in)
{
}

void
IceAsync::iBS::AMD_BigMatrixService_RecalculateObserverStats::ice_response(::Ice::Int __ret, ::Ice::Long taskID)
{
    if(__validateResponse(true))
    {
        try
        {
            ::IceInternal::BasicStream* __os = __startWriteParams(::Ice::DefaultFormat);
            __os->write(taskID);
            __os->write(__ret);
            __endWriteParams(true);
        }
        catch(const ::Ice::Exception& __ex)
        {
            __exception(__ex);
            return;
        }
        __response();
    }
}

void
IceAsync::iBS::AMD_BigMatrixService_RecalculateObserverStats::ice_exception(const ::std::exception& ex)
{
    if(const ::iBS::ArgumentException* __ex = dynamic_cast<const ::iBS::ArgumentException*>(&ex))
    {
        if(__validateResponse(false))
        {
            __writeUserException(*__ex, ::Ice::DefaultFormat);
            __response();
        }
    }
    else
    {
        ::IceInternal::IncomingAsync::ice_exception(ex);
    }
}
::IceProxy::Ice::Object* ::IceProxy::iBS::upCast(::IceProxy::iBS::ProxyCentralService* p) { return p; }

void
::IceProxy::iBS::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::iBS::ProxyCentralService>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::iBS::ProxyCentralService;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::iBS::ProxyCentralService::RegisterByCallerAdress(const ::std::string& servantName, const ::std::string& proxyStrNoHost, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__ProxyCentralService__RegisterByCallerAdress_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__ProxyCentralService__RegisterByCallerAdress_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::ProxyCentralService* __del = dynamic_cast< ::IceDelegate::iBS::ProxyCentralService*>(__delBase.get());
            return __del->RegisterByCallerAdress(servantName, proxyStrNoHost, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::ProxyCentralService::begin_RegisterByCallerAdress(const ::std::string& servantName, const ::std::string& proxyStrNoHost, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__ProxyCentralService__RegisterByCallerAdress_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__ProxyCentralService__RegisterByCallerAdress_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__ProxyCentralService__RegisterByCallerAdress_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(servantName);
        __os->write(proxyStrNoHost);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::ProxyCentralService::end_RegisterByCallerAdress(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__ProxyCentralService__RegisterByCallerAdress_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::ProxyCentralService::RegisterByProxyStr(const ::std::string& servantName, const ::std::string& proxyStr, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__ProxyCentralService__RegisterByProxyStr_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__ProxyCentralService__RegisterByProxyStr_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::ProxyCentralService* __del = dynamic_cast< ::IceDelegate::iBS::ProxyCentralService*>(__delBase.get());
            return __del->RegisterByProxyStr(servantName, proxyStr, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::ProxyCentralService::begin_RegisterByProxyStr(const ::std::string& servantName, const ::std::string& proxyStr, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__ProxyCentralService__RegisterByProxyStr_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__ProxyCentralService__RegisterByProxyStr_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__ProxyCentralService__RegisterByProxyStr_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(servantName);
        __os->write(proxyStr);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::ProxyCentralService::end_RegisterByProxyStr(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__ProxyCentralService__RegisterByProxyStr_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::ProxyCentralService::UnRegister(const ::std::string& servantName, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__ProxyCentralService__UnRegister_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__ProxyCentralService__UnRegister_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::ProxyCentralService* __del = dynamic_cast< ::IceDelegate::iBS::ProxyCentralService*>(__delBase.get());
            return __del->UnRegister(servantName, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::ProxyCentralService::begin_UnRegister(const ::std::string& servantName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__ProxyCentralService__UnRegister_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__ProxyCentralService__UnRegister_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__ProxyCentralService__UnRegister_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(servantName);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::ProxyCentralService::end_UnRegister(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__ProxyCentralService__UnRegister_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::ProxyCentralService::UnRegisterAll(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__ProxyCentralService__UnRegisterAll_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__ProxyCentralService__UnRegisterAll_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::ProxyCentralService* __del = dynamic_cast< ::IceDelegate::iBS::ProxyCentralService*>(__delBase.get());
            return __del->UnRegisterAll(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::ProxyCentralService::begin_UnRegisterAll(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__ProxyCentralService__UnRegisterAll_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__ProxyCentralService__UnRegisterAll_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__ProxyCentralService__UnRegisterAll_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::ProxyCentralService::end_UnRegisterAll(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__ProxyCentralService__UnRegisterAll_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::ProxyCentralService::ListAll(::iBS::StringVec& proxyStrs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__ProxyCentralService__ListAll_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__ProxyCentralService__ListAll_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::ProxyCentralService* __del = dynamic_cast< ::IceDelegate::iBS::ProxyCentralService*>(__delBase.get());
            return __del->ListAll(proxyStrs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::ProxyCentralService::begin_ListAll(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__ProxyCentralService__ListAll_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__ProxyCentralService__ListAll_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__ProxyCentralService__ListAll_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::ProxyCentralService::end_ListAll(::iBS::StringVec& proxyStrs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__ProxyCentralService__ListAll_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(proxyStrs);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::iBS::ProxyCentralService::ice_staticId()
{
    return ::iBS::ProxyCentralService::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::iBS::ProxyCentralService::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::iBS::ProxyCentralService);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::iBS::ProxyCentralService::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::iBS::ProxyCentralService);
}

::IceProxy::Ice::Object*
IceProxy::iBS::ProxyCentralService::__newInstance() const
{
    return new ProxyCentralService;
}
::IceProxy::Ice::Object* ::IceProxy::iBS::upCast(::IceProxy::iBS::FcdcReadService* p) { return p; }

void
::IceProxy::iBS::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::iBS::FcdcReadService>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::iBS::FcdcReadService;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetFeatureDomains(const ::iBS::IntVec& domainIDs, ::iBS::FeatureDomainInfoVec& domainInfos, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetFeatureDomains_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetFeatureDomains_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetFeatureDomains(domainIDs, domainInfos, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetFeatureDomains(const ::iBS::IntVec& domainIDs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetFeatureDomains_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetFeatureDomains_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetFeatureDomains_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(domainIDs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetFeatureDomains(::iBS::FeatureDomainInfoVec& domainInfos, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetFeatureDomains_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(domainInfos);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetFeatureObservers(const ::iBS::IntVec& observerIDs, ::iBS::FeatureObserverInfoVec& observerInfos, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetFeatureObservers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetFeatureObservers_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetFeatureObservers(observerIDs, observerInfos, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetFeatureObservers(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetFeatureObservers_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetFeatureObservers_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetFeatureObservers_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetFeatureObservers(::iBS::FeatureObserverInfoVec& observerInfos, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetFeatureObservers_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(observerInfos);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetDoublesColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, ::iBS::DoubleVec& values, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetDoublesColumnVector_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetDoublesColumnVector_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetDoublesColumnVector(observerID, featureIdxFrom, featureIdxTo, values, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetDoublesColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetDoublesColumnVector_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetDoublesColumnVector_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetDoublesColumnVector_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetDoublesColumnVector(::iBS::DoubleVec& values, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetDoublesColumnVector_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(values);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::iBS::FcdcReadService::___end_GetDoublesColumnVector(::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& values, ::Ice::Int& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetDoublesColumnVector_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::iBS::ArgumentException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(values);
    __is->read(__ret);
    __result->__endReadParams();
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetIntsColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, ::iBS::IntVec& values, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetIntsColumnVector_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetIntsColumnVector_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetIntsColumnVector(observerID, featureIdxFrom, featureIdxTo, values, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetIntsColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetIntsColumnVector_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetIntsColumnVector_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetIntsColumnVector_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetIntsColumnVector(::iBS::IntVec& values, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetIntsColumnVector_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(values);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::iBS::FcdcReadService::___end_GetIntsColumnVector(::std::pair< ::IceUtil::ScopedArray< ::Ice::Int>, ::std::pair<const  ::Ice::Int*, const  ::Ice::Int*> >& values, ::Ice::Int& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetIntsColumnVector_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::iBS::ArgumentException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(values);
    __is->read(__ret);
    __result->__endReadParams();
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetDoublesRowMatrix(::Ice::Int observerGroupID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, ::iBS::DoubleVec& values, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetDoublesRowMatrix_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetDoublesRowMatrix_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetDoublesRowMatrix(observerGroupID, featureIdxFrom, featureIdxTo, values, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetDoublesRowMatrix(::Ice::Int observerGroupID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetDoublesRowMatrix_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetDoublesRowMatrix_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetDoublesRowMatrix_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerGroupID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetDoublesRowMatrix(::iBS::DoubleVec& values, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetDoublesRowMatrix_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(values);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::iBS::FcdcReadService::___end_GetDoublesRowMatrix(::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& values, ::Ice::Int& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetDoublesRowMatrix_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::iBS::ArgumentException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(values);
    __is->read(__ret);
    __result->__endReadParams();
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetObserverStats(::Ice::Int observerID, ::iBS::ObserverStatsInfo& stats, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetObserverStats_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetObserverStats_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetObserverStats(observerID, stats, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetObserverStats(::Ice::Int observerID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetObserverStats_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetObserverStats_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetObserverStats_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetObserverStats(::iBS::ObserverStatsInfo& stats, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetObserverStats_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(stats);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetObserversStats(const ::iBS::IntVec& observerIDs, ::iBS::ObserverStatsInfoVec& observerStats, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetObserversStats_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetObserversStats_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetObserversStats(observerIDs, observerStats, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetObserversStats(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetObserversStats_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetObserversStats_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetObserversStats_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetObserversStats(::iBS::ObserverStatsInfoVec& observerStats, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetObserversStats_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(observerStats);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetRowMatrix(const ::iBS::IntVec& observerIDs, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const IceUtil::Optional< ::iBS::RowAdjustEnum>& rowAdjust, ::iBS::DoubleVec& values, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetRowMatrix_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetRowMatrix_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetRowMatrix(observerIDs, featureIdxFrom, featureIdxTo, rowAdjust, values, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetRowMatrix(const ::iBS::IntVec& observerIDs, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const IceUtil::Optional< ::iBS::RowAdjustEnum>& rowAdjust, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetRowMatrix_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetRowMatrix_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetRowMatrix_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(1, rowAdjust);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetRowMatrix(::iBS::DoubleVec& values, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetRowMatrix_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(values);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::iBS::FcdcReadService::___end_GetRowMatrix(::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& values, ::Ice::Int& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetRowMatrix_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::iBS::ArgumentException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(values);
    __is->read(__ret);
    __result->__endReadParams();
}

::Ice::Int
IceProxy::iBS::FcdcReadService::SampleRowMatrix(const ::iBS::IntVec& observerIDs, const ::iBS::LongVec& featureIdxs, const IceUtil::Optional< ::iBS::RowAdjustEnum>& rowAdjust, ::iBS::DoubleVec& values, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__SampleRowMatrix_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__SampleRowMatrix_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->SampleRowMatrix(observerIDs, featureIdxs, rowAdjust, values, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_SampleRowMatrix(const ::iBS::IntVec& observerIDs, const ::iBS::LongVec& featureIdxs, const IceUtil::Optional< ::iBS::RowAdjustEnum>& rowAdjust, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__SampleRowMatrix_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__SampleRowMatrix_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__SampleRowMatrix_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __os->write(featureIdxs);
        __os->write(1, rowAdjust);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_SampleRowMatrix(::iBS::DoubleVec& values, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__SampleRowMatrix_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(values);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::iBS::FcdcReadService::___end_SampleRowMatrix(::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& values, ::Ice::Int& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__SampleRowMatrix_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::iBS::ArgumentException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(values);
    __is->read(__ret);
    __result->__endReadParams();
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetObserverIndex(::Ice::Int observerID, ::iBS::ObserverIndexInfo& oii, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetObserverIndex_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetObserverIndex_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetObserverIndex(observerID, oii, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetObserverIndex(::Ice::Int observerID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetObserverIndex_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetObserverIndex_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetObserverIndex_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetObserverIndex(::iBS::ObserverIndexInfo& oii, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetObserverIndex_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(oii);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetFeatureIdxsByIntKeys(::Ice::Int observerID, const ::iBS::IntVec& keys, ::Ice::Long maxFeatureCnt, ::iBS::LongVec& featureIdxs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetFeatureIdxsByIntKeys_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetFeatureIdxsByIntKeys_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetFeatureIdxsByIntKeys(observerID, keys, maxFeatureCnt, featureIdxs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetFeatureIdxsByIntKeys(::Ice::Int observerID, const ::iBS::IntVec& keys, ::Ice::Long maxFeatureCnt, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetFeatureIdxsByIntKeys_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetFeatureIdxsByIntKeys_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetFeatureIdxsByIntKeys_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(keys);
        __os->write(maxFeatureCnt);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetFeatureIdxsByIntKeys(::iBS::LongVec& featureIdxs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetFeatureIdxsByIntKeys_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(featureIdxs);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::iBS::FcdcReadService::___end_GetFeatureIdxsByIntKeys(::std::pair< ::IceUtil::ScopedArray< ::Ice::Long>, ::std::pair<const  ::Ice::Long*, const  ::Ice::Long*> >& featureIdxs, ::Ice::Int& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetFeatureIdxsByIntKeys_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::iBS::ArgumentException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(featureIdxs);
    __is->read(__ret);
    __result->__endReadParams();
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetFeatureCntsByIntKeys(::Ice::Int observerID, const ::iBS::IntVec& keys, ::iBS::LongVec& featureCnts, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetFeatureCntsByIntKeys_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetFeatureCntsByIntKeys_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetFeatureCntsByIntKeys(observerID, keys, featureCnts, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetFeatureCntsByIntKeys(::Ice::Int observerID, const ::iBS::IntVec& keys, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetFeatureCntsByIntKeys_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetFeatureCntsByIntKeys_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetFeatureCntsByIntKeys_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(keys);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetFeatureCntsByIntKeys(::iBS::LongVec& featureCnts, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetFeatureCntsByIntKeys_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(featureCnts);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::iBS::FcdcReadService::___end_GetFeatureCntsByIntKeys(::std::pair< ::IceUtil::ScopedArray< ::Ice::Long>, ::std::pair<const  ::Ice::Long*, const  ::Ice::Long*> >& featureCnts, ::Ice::Int& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetFeatureCntsByIntKeys_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::iBS::ArgumentException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(featureCnts);
    __is->read(__ret);
    __result->__endReadParams();
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetAMDTaskInfo(::Ice::Long taskID, ::iBS::AMDTaskInfo& task, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetAMDTaskInfo_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetAMDTaskInfo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetAMDTaskInfo(taskID, task, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetAMDTaskInfo(::Ice::Long taskID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetAMDTaskInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetAMDTaskInfo_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetAMDTaskInfo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(taskID);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetAMDTaskInfo(::iBS::AMDTaskInfo& task, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetAMDTaskInfo_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(task);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetFeatureValueStoreDir(::std::string& rootDir, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetFeatureValueStoreDir_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetFeatureValueStoreDir_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetFeatureValueStoreDir(rootDir, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetFeatureValueStoreDir(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetFeatureValueStoreDir_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetFeatureValueStoreDir_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetFeatureValueStoreDir_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetFeatureValueStoreDir(::std::string& rootDir, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetFeatureValueStoreDir_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(rootDir);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadService::GetFeatureValuePathPrefix(::Ice::Int observerID, ::std::string& pathPrefix, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadService__GetFeatureValuePathPrefix_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadService__GetFeatureValuePathPrefix_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadService*>(__delBase.get());
            return __del->GetFeatureValuePathPrefix(observerID, pathPrefix, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadService::begin_GetFeatureValuePathPrefix(::Ice::Int observerID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadService__GetFeatureValuePathPrefix_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadService__GetFeatureValuePathPrefix_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadService__GetFeatureValuePathPrefix_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadService::end_GetFeatureValuePathPrefix(::std::string& pathPrefix, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadService__GetFeatureValuePathPrefix_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(pathPrefix);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::iBS::FcdcReadService::ice_staticId()
{
    return ::iBS::FcdcReadService::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::iBS::FcdcReadService::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::iBS::FcdcReadService);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::iBS::FcdcReadService::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::iBS::FcdcReadService);
}

::IceProxy::Ice::Object*
IceProxy::iBS::FcdcReadService::__newInstance() const
{
    return new FcdcReadService;
}
::IceProxy::Ice::Object* ::IceProxy::iBS::upCast(::IceProxy::iBS::FcdcReadWriteService* p) { return p; }

void
::IceProxy::iBS::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::iBS::FcdcReadWriteService>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::iBS::FcdcReadWriteService;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::SetFeatureDomains(const ::iBS::FeatureDomainInfoVec& domainInfos, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadWriteService__SetFeatureDomains_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadWriteService__SetFeatureDomains_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadWriteService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadWriteService*>(__delBase.get());
            return __del->SetFeatureDomains(domainInfos, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadWriteService::begin_SetFeatureDomains(const ::iBS::FeatureDomainInfoVec& domainInfos, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadWriteService__SetFeatureDomains_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadWriteService__SetFeatureDomains_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadWriteService__SetFeatureDomains_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(domainInfos);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::end_SetFeatureDomains(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadWriteService__SetFeatureDomains_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::SetFeatureObservers(const ::iBS::FeatureObserverInfoVec& observerInfos, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadWriteService__SetFeatureObservers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadWriteService__SetFeatureObservers_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadWriteService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadWriteService*>(__delBase.get());
            return __del->SetFeatureObservers(observerInfos, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadWriteService::begin_SetFeatureObservers(const ::iBS::FeatureObserverInfoVec& observerInfos, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadWriteService__SetFeatureObservers_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadWriteService__SetFeatureObservers_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadWriteService__SetFeatureObservers_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerInfos);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::end_SetFeatureObservers(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadWriteService__SetFeatureObservers_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::SetDoublesColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& values, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadWriteService__SetDoublesColumnVector_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadWriteService__SetDoublesColumnVector_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadWriteService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadWriteService*>(__delBase.get());
            return __del->SetDoublesColumnVector(observerID, featureIdxFrom, featureIdxTo, values, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadWriteService::begin_SetDoublesColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& values, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadWriteService__SetDoublesColumnVector_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadWriteService__SetDoublesColumnVector_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadWriteService__SetDoublesColumnVector_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(values);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::end_SetDoublesColumnVector(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadWriteService__SetDoublesColumnVector_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::SetBytesColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& bytes, ::iBS::ByteArrayContentEnum content, ::iBS::ByteArrayEndianEnum endian, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadWriteService__SetBytesColumnVector_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadWriteService__SetBytesColumnVector_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadWriteService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadWriteService*>(__delBase.get());
            return __del->SetBytesColumnVector(observerID, featureIdxFrom, featureIdxTo, bytes, content, endian, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadWriteService::begin_SetBytesColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& bytes, ::iBS::ByteArrayContentEnum content, ::iBS::ByteArrayEndianEnum endian, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadWriteService__SetBytesColumnVector_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadWriteService__SetBytesColumnVector_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadWriteService__SetBytesColumnVector_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(bytes);
        __os->write(content);
        __os->write(endian);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::end_SetBytesColumnVector(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadWriteService__SetBytesColumnVector_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::SetIntsColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Int*, const ::Ice::Int*>& values, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadWriteService__SetIntsColumnVector_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadWriteService__SetIntsColumnVector_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadWriteService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadWriteService*>(__delBase.get());
            return __del->SetIntsColumnVector(observerID, featureIdxFrom, featureIdxTo, values, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadWriteService::begin_SetIntsColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Int*, const ::Ice::Int*>& values, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadWriteService__SetIntsColumnVector_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadWriteService__SetIntsColumnVector_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadWriteService__SetIntsColumnVector_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(values);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::end_SetIntsColumnVector(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadWriteService__SetIntsColumnVector_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::SetDoublesRowMatrix(::Ice::Int observerGroupID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& values, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcReadWriteService__SetDoublesRowMatrix_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcReadWriteService__SetDoublesRowMatrix_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcReadWriteService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcReadWriteService*>(__delBase.get());
            return __del->SetDoublesRowMatrix(observerGroupID, featureIdxFrom, featureIdxTo, values, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcReadWriteService::begin_SetDoublesRowMatrix(::Ice::Int observerGroupID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& values, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcReadWriteService__SetDoublesRowMatrix_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcReadWriteService__SetDoublesRowMatrix_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcReadWriteService__SetDoublesRowMatrix_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerGroupID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(values);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcReadWriteService::end_SetDoublesRowMatrix(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcReadWriteService__SetDoublesRowMatrix_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::iBS::FcdcReadWriteService::ice_staticId()
{
    return ::iBS::FcdcReadWriteService::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::iBS::FcdcReadWriteService::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::iBS::FcdcReadWriteService);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::iBS::FcdcReadWriteService::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::iBS::FcdcReadWriteService);
}

::IceProxy::Ice::Object*
IceProxy::iBS::FcdcReadWriteService::__newInstance() const
{
    return new FcdcReadWriteService;
}
::IceProxy::Ice::Object* ::IceProxy::iBS::upCast(::IceProxy::iBS::FcdcAdminService* p) { return p; }

void
::IceProxy::iBS::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::iBS::FcdcAdminService>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::iBS::FcdcAdminService;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::iBS::FcdcAdminService::Shutdown(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__Shutdown_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            __del->Shutdown(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_Shutdown(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__Shutdown_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__Shutdown_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::iBS::FcdcAdminService::end_Shutdown(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __iBS__FcdcAdminService__Shutdown_name);
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::RqstNewFeatureDomainID(::Ice::Int& domainID, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__RqstNewFeatureDomainID_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcAdminService__RqstNewFeatureDomainID_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            return __del->RqstNewFeatureDomainID(domainID, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_RqstNewFeatureDomainID(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcAdminService__RqstNewFeatureDomainID_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__RqstNewFeatureDomainID_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__RqstNewFeatureDomainID_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::end_RqstNewFeatureDomainID(::Ice::Int& domainID, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcAdminService__RqstNewFeatureDomainID_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(domainID);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::RqstNewFeatureObserverID(bool inRAMNoSave, ::Ice::Int& observerID, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__RqstNewFeatureObserverID_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcAdminService__RqstNewFeatureObserverID_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            return __del->RqstNewFeatureObserverID(inRAMNoSave, observerID, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_RqstNewFeatureObserverID(bool inRAMNoSave, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcAdminService__RqstNewFeatureObserverID_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__RqstNewFeatureObserverID_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__RqstNewFeatureObserverID_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inRAMNoSave);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::end_RqstNewFeatureObserverID(::Ice::Int& observerID, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcAdminService__RqstNewFeatureObserverID_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(observerID);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::RqstNewFeatureObserversInGroup(::Ice::Int groupSize, bool inRAMNoSave, ::iBS::IntVec& observerIDs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__RqstNewFeatureObserversInGroup_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcAdminService__RqstNewFeatureObserversInGroup_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            return __del->RqstNewFeatureObserversInGroup(groupSize, inRAMNoSave, observerIDs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_RqstNewFeatureObserversInGroup(::Ice::Int groupSize, bool inRAMNoSave, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcAdminService__RqstNewFeatureObserversInGroup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__RqstNewFeatureObserversInGroup_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__RqstNewFeatureObserversInGroup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(groupSize);
        __os->write(inRAMNoSave);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::end_RqstNewFeatureObserversInGroup(::iBS::IntVec& observerIDs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcAdminService__RqstNewFeatureObserversInGroup_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(observerIDs);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::AttachBigMatrix(::Ice::Int colCnt, ::Ice::Long rowCnt, const ::iBS::StringVec& colNames, const ::std::string& storePathPrefix, ::iBS::IntVec& OIDs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__AttachBigMatrix_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcAdminService__AttachBigMatrix_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            return __del->AttachBigMatrix(colCnt, rowCnt, colNames, storePathPrefix, OIDs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_AttachBigMatrix(::Ice::Int colCnt, ::Ice::Long rowCnt, const ::iBS::StringVec& colNames, const ::std::string& storePathPrefix, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcAdminService__AttachBigMatrix_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__AttachBigMatrix_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__AttachBigMatrix_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(colCnt);
        __os->write(rowCnt);
        __os->write(colNames);
        __os->write(storePathPrefix);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::end_AttachBigMatrix(::iBS::IntVec& OIDs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcAdminService__AttachBigMatrix_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(OIDs);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::AttachBigVector(::Ice::Long rowCnt, const ::std::string& colName, const ::std::string& storePathPrefix, ::Ice::Int& OID, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__AttachBigVector_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcAdminService__AttachBigVector_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            return __del->AttachBigVector(rowCnt, colName, storePathPrefix, OID, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_AttachBigVector(::Ice::Long rowCnt, const ::std::string& colName, const ::std::string& storePathPrefix, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcAdminService__AttachBigVector_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__AttachBigVector_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__AttachBigVector_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(rowCnt);
        __os->write(colName);
        __os->write(storePathPrefix);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::end_AttachBigVector(::Ice::Int& OID, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcAdminService__AttachBigVector_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(OID);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::ForceLoadInRAM(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__ForceLoadInRAM_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcAdminService__ForceLoadInRAM_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            return __del->ForceLoadInRAM(observerIDs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_ForceLoadInRAM(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcAdminService__ForceLoadInRAM_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__ForceLoadInRAM_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__ForceLoadInRAM_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::end_ForceLoadInRAM(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcAdminService__ForceLoadInRAM_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::ForceLeaveRAM(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__ForceLeaveRAM_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcAdminService__ForceLeaveRAM_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            return __del->ForceLeaveRAM(observerIDs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_ForceLeaveRAM(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcAdminService__ForceLeaveRAM_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__ForceLeaveRAM_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__ForceLeaveRAM_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::end_ForceLeaveRAM(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcAdminService__ForceLeaveRAM_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::RecalculateObserverStats(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__RecalculateObserverStats_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcAdminService__RecalculateObserverStats_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            return __del->RecalculateObserverStats(observerIDs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_RecalculateObserverStats(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcAdminService__RecalculateObserverStats_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__RecalculateObserverStats_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__RecalculateObserverStats_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::end_RecalculateObserverStats(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcAdminService__RecalculateObserverStats_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::RecalculateObserverIndex(::Ice::Int observerID, bool saveIndexFile, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__RecalculateObserverIndex_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcAdminService__RecalculateObserverIndex_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            return __del->RecalculateObserverIndex(observerID, saveIndexFile, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_RecalculateObserverIndex(::Ice::Int observerID, bool saveIndexFile, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcAdminService__RecalculateObserverIndex_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__RecalculateObserverIndex_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__RecalculateObserverIndex_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(saveIndexFile);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::end_RecalculateObserverIndex(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcAdminService__RecalculateObserverIndex_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::RemoveFeatureObservers(const ::iBS::IntVec& observerIDs, bool removeDataFile, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__RemoveFeatureObservers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcAdminService__RemoveFeatureObservers_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            return __del->RemoveFeatureObservers(observerIDs, removeDataFile, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_RemoveFeatureObservers(const ::iBS::IntVec& observerIDs, bool removeDataFile, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcAdminService__RemoveFeatureObservers_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__RemoveFeatureObservers_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__RemoveFeatureObservers_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __os->write(removeDataFile);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::end_RemoveFeatureObservers(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcAdminService__RemoveFeatureObservers_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::SetObserverStats(const ::iBS::ObserverStatsInfoVec& osis, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcAdminService__SetObserverStats_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcAdminService__SetObserverStats_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcAdminService*>(__delBase.get());
            return __del->SetObserverStats(osis, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcAdminService::begin_SetObserverStats(const ::iBS::ObserverStatsInfoVec& osis, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcAdminService__SetObserverStats_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcAdminService__SetObserverStats_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcAdminService__SetObserverStats_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(osis);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcAdminService::end_SetObserverStats(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcAdminService__SetObserverStats_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::iBS::FcdcAdminService::ice_staticId()
{
    return ::iBS::FcdcAdminService::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::iBS::FcdcAdminService::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::iBS::FcdcAdminService);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::iBS::FcdcAdminService::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::iBS::FcdcAdminService);
}

::IceProxy::Ice::Object*
IceProxy::iBS::FcdcAdminService::__newInstance() const
{
    return new FcdcAdminService;
}
::IceProxy::Ice::Object* ::IceProxy::iBS::upCast(::IceProxy::iBS::FcdcRUVService* p) { return p; }

void
::IceProxy::iBS::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::iBS::FcdcRUVService>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::iBS::FcdcRUVService;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::SetActiveK(::Ice::Int k, ::Ice::Int extW, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__SetActiveK_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__SetActiveK_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->SetActiveK(k, extW, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_SetActiveK(::Ice::Int k, ::Ice::Int extW, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__SetActiveK_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__SetActiveK_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__SetActiveK_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(k);
        __os->write(extW);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_SetActiveK(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__SetActiveK_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::SetOutputMode(::iBS::RUVOutputModeEnum mode, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__SetOutputMode_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__SetOutputMode_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->SetOutputMode(mode, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_SetOutputMode(::iBS::RUVOutputModeEnum mode, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__SetOutputMode_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__SetOutputMode_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__SetOutputMode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(mode);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_SetOutputMode(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__SetOutputMode_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::SetOutputSamples(const ::iBS::IntVec& sampleIDs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__SetOutputSamples_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__SetOutputSamples_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->SetOutputSamples(sampleIDs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_SetOutputSamples(const ::iBS::IntVec& sampleIDs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__SetOutputSamples_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__SetOutputSamples_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__SetOutputSamples_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(sampleIDs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_SetOutputSamples(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__SetOutputSamples_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::ExcludeSamplesForGroupMean(const ::iBS::IntVec& excludeSampleIDs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__ExcludeSamplesForGroupMean_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__ExcludeSamplesForGroupMean_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->ExcludeSamplesForGroupMean(excludeSampleIDs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_ExcludeSamplesForGroupMean(const ::iBS::IntVec& excludeSampleIDs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__ExcludeSamplesForGroupMean_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__ExcludeSamplesForGroupMean_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__ExcludeSamplesForGroupMean_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(excludeSampleIDs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_ExcludeSamplesForGroupMean(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__ExcludeSamplesForGroupMean_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::SetOutputScale(::iBS::RUVOutputScaleEnum scale, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__SetOutputScale_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__SetOutputScale_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->SetOutputScale(scale, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_SetOutputScale(::iBS::RUVOutputScaleEnum scale, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__SetOutputScale_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__SetOutputScale_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__SetOutputScale_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(scale);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_SetOutputScale(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__SetOutputScale_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::SetOutputWorkerNum(::Ice::Int workerNum, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__SetOutputWorkerNum_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__SetOutputWorkerNum_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->SetOutputWorkerNum(workerNum, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_SetOutputWorkerNum(::Ice::Int workerNum, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__SetOutputWorkerNum_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__SetOutputWorkerNum_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__SetOutputWorkerNum_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(workerNum);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_SetOutputWorkerNum(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__SetOutputWorkerNum_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::SetCtrlQuantileValues(::Ice::Double quantile, const ::iBS::DoubleVec& qvalues, ::Ice::Double fration, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__SetCtrlQuantileValues_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__SetCtrlQuantileValues_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->SetCtrlQuantileValues(quantile, qvalues, fration, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_SetCtrlQuantileValues(::Ice::Double quantile, const ::iBS::DoubleVec& qvalues, ::Ice::Double fration, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__SetCtrlQuantileValues_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__SetCtrlQuantileValues_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__SetCtrlQuantileValues_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(quantile);
        __os->write(qvalues);
        __os->write(fration);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_SetCtrlQuantileValues(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__SetCtrlQuantileValues_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::RebuildRUVModel(::Ice::Int threadCnt, ::Ice::Long ramMb, ::Ice::Long& taskID, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__RebuildRUVModel_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__RebuildRUVModel_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->RebuildRUVModel(threadCnt, ramMb, taskID, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_RebuildRUVModel(::Ice::Int threadCnt, ::Ice::Long ramMb, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__RebuildRUVModel_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__RebuildRUVModel_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__RebuildRUVModel_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(threadCnt);
        __os->write(ramMb);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_RebuildRUVModel(::Ice::Long& taskID, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__RebuildRUVModel_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(taskID);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::GetConditionIdxs(const ::iBS::IntVec& observerIDs, ::iBS::IntVec& conditionIdxs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__GetConditionIdxs_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__GetConditionIdxs_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->GetConditionIdxs(observerIDs, conditionIdxs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_GetConditionIdxs(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__GetConditionIdxs_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__GetConditionIdxs_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__GetConditionIdxs_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_GetConditionIdxs(::iBS::IntVec& conditionIdxs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__GetConditionIdxs_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(conditionIdxs);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::GetConditionInfos(::iBS::ConditionInfoVec& conditions, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__GetConditionInfos_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__GetConditionInfos_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->GetConditionInfos(conditions, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_GetConditionInfos(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__GetConditionInfos_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__GetConditionInfos_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__GetConditionInfos_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_GetConditionInfos(::iBS::ConditionInfoVec& conditions, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__GetConditionInfos_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(conditions);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::GetSamplesInGroups(const ::iBS::IntVec& sampleIDs, ::iBS::IntVecVec& groupSampleIDs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__GetSamplesInGroups_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__GetSamplesInGroups_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->GetSamplesInGroups(sampleIDs, groupSampleIDs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_GetSamplesInGroups(const ::iBS::IntVec& sampleIDs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__GetSamplesInGroups_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__GetSamplesInGroups_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__GetSamplesInGroups_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(sampleIDs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_GetSamplesInGroups(::iBS::IntVecVec& groupSampleIDs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__GetSamplesInGroups_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(groupSampleIDs);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::GetG(::iBS::DoubleVec& values, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__GetG_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__GetG_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->GetG(values, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_GetG(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__GetG_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__GetG_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__GetG_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_GetG(::iBS::DoubleVec& values, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__GetG_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(values);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::iBS::FcdcRUVService::___end_GetG(::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& values, ::Ice::Int& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__GetG_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::iBS::ArgumentException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(values);
    __is->read(__ret);
    __result->__endReadParams();
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::GetWt(::iBS::DoubleVec& values, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__GetWt_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__GetWt_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->GetWt(values, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_GetWt(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__GetWt_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__GetWt_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__GetWt_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_GetWt(::iBS::DoubleVec& values, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__GetWt_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(values);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void IceProxy::iBS::FcdcRUVService::___end_GetWt(::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> >& values, ::Ice::Int& __ret, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__GetWt_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::iBS::ArgumentException&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(values);
    __is->read(__ret);
    __result->__endReadParams();
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::GetEigenVals(::iBS::DoubleVec& values, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__GetEigenVals_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__GetEigenVals_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->GetEigenVals(values, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_GetEigenVals(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__GetEigenVals_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__GetEigenVals_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__GetEigenVals_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_GetEigenVals(::iBS::DoubleVec& values, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__GetEigenVals_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(values);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::SelectKByEigenVals(::Ice::Double minFraction, ::Ice::Int& k, ::iBS::DoubleVec& fractions, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__SelectKByEigenVals_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__SelectKByEigenVals_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->SelectKByEigenVals(minFraction, k, fractions, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_SelectKByEigenVals(::Ice::Double minFraction, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__SelectKByEigenVals_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__SelectKByEigenVals_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__SelectKByEigenVals_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(minFraction);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_SelectKByEigenVals(::Ice::Int& k, ::iBS::DoubleVec& fractions, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__SelectKByEigenVals_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(k);
        __is->read(fractions);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::DecomposeVariance(const ::iBS::IntVec& ks, const ::iBS::IntVec& extWs, const ::iBS::IntVecVec& wtVecIdxs, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, ::Ice::Int threadCnt, ::Ice::Long ramMb, const ::std::string& outfile, ::iBS::RUVVarDecomposeInfoVec& vds, ::Ice::Long& taskID, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__DecomposeVariance_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__DecomposeVariance_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->DecomposeVariance(ks, extWs, wtVecIdxs, featureIdxFrom, featureIdxTo, threadCnt, ramMb, outfile, vds, taskID, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_DecomposeVariance(const ::iBS::IntVec& ks, const ::iBS::IntVec& extWs, const ::iBS::IntVecVec& wtVecIdxs, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, ::Ice::Int threadCnt, ::Ice::Long ramMb, const ::std::string& outfile, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__DecomposeVariance_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__DecomposeVariance_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__DecomposeVariance_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(ks);
        __os->write(extWs);
        __os->write(wtVecIdxs);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(threadCnt);
        __os->write(ramMb);
        __os->write(outfile);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_DecomposeVariance(::iBS::RUVVarDecomposeInfoVec& vds, ::Ice::Long& taskID, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__DecomposeVariance_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(vds);
        __is->read(taskID);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::SetWtVectorIdxs(const ::iBS::IntVec& vecIdxs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcRUVService__SetWtVectorIdxs_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcRUVService__SetWtVectorIdxs_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcRUVService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcRUVService*>(__delBase.get());
            return __del->SetWtVectorIdxs(vecIdxs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcRUVService::begin_SetWtVectorIdxs(const ::iBS::IntVec& vecIdxs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcRUVService__SetWtVectorIdxs_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcRUVService__SetWtVectorIdxs_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcRUVService__SetWtVectorIdxs_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(vecIdxs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcRUVService::end_SetWtVectorIdxs(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcRUVService__SetWtVectorIdxs_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::iBS::FcdcRUVService::ice_staticId()
{
    return ::iBS::FcdcRUVService::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::iBS::FcdcRUVService::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::iBS::FcdcRUVService);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::iBS::FcdcRUVService::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::iBS::FcdcRUVService);
}

::IceProxy::Ice::Object*
IceProxy::iBS::FcdcRUVService::__newInstance() const
{
    return new FcdcRUVService;
}
::IceProxy::Ice::Object* ::IceProxy::iBS::upCast(::IceProxy::iBS::BigMatrixService* p) { return p; }

void
::IceProxy::iBS::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::iBS::BigMatrixService>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::iBS::BigMatrixService;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::iBS::BigMatrixService::SetOutputSamples(const ::iBS::IntVec& sampleIDs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__BigMatrixService__SetOutputSamples_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__BigMatrixService__SetOutputSamples_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::BigMatrixService* __del = dynamic_cast< ::IceDelegate::iBS::BigMatrixService*>(__delBase.get());
            return __del->SetOutputSamples(sampleIDs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::BigMatrixService::begin_SetOutputSamples(const ::iBS::IntVec& sampleIDs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__BigMatrixService__SetOutputSamples_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__BigMatrixService__SetOutputSamples_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__BigMatrixService__SetOutputSamples_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(sampleIDs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::BigMatrixService::end_SetOutputSamples(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__BigMatrixService__SetOutputSamples_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::BigMatrixService::SetRowAdjust(::iBS::RowAdjustEnum rowAdjust, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__BigMatrixService__SetRowAdjust_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__BigMatrixService__SetRowAdjust_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::BigMatrixService* __del = dynamic_cast< ::IceDelegate::iBS::BigMatrixService*>(__delBase.get());
            return __del->SetRowAdjust(rowAdjust, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::BigMatrixService::begin_SetRowAdjust(::iBS::RowAdjustEnum rowAdjust, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__BigMatrixService__SetRowAdjust_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__BigMatrixService__SetRowAdjust_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__BigMatrixService__SetRowAdjust_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(rowAdjust);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::BigMatrixService::end_SetRowAdjust(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__BigMatrixService__SetRowAdjust_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::BigMatrixService::RecalculateObserverStats(::Ice::Long ramMb, ::Ice::Long& taskID, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__BigMatrixService__RecalculateObserverStats_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__BigMatrixService__RecalculateObserverStats_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::BigMatrixService* __del = dynamic_cast< ::IceDelegate::iBS::BigMatrixService*>(__delBase.get());
            return __del->RecalculateObserverStats(ramMb, taskID, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::BigMatrixService::begin_RecalculateObserverStats(::Ice::Long ramMb, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__BigMatrixService__RecalculateObserverStats_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__BigMatrixService__RecalculateObserverStats_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__BigMatrixService__RecalculateObserverStats_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(ramMb);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::BigMatrixService::end_RecalculateObserverStats(::Ice::Long& taskID, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__BigMatrixService__RecalculateObserverStats_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(taskID);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::iBS::BigMatrixService::ice_staticId()
{
    return ::iBS::BigMatrixService::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::iBS::BigMatrixService::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::iBS::BigMatrixService);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::iBS::BigMatrixService::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::iBS::BigMatrixService);
}

::IceProxy::Ice::Object*
IceProxy::iBS::BigMatrixService::__newInstance() const
{
    return new BigMatrixService;
}
::IceProxy::Ice::Object* ::IceProxy::iBS::upCast(::IceProxy::iBS::FcdcFacetAdminService* p) { return p; }

void
::IceProxy::iBS::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::iBS::FcdcFacetAdminService>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::iBS::FcdcFacetAdminService;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::iBS::FcdcFacetAdminService::RqstNewRUVFacet(::iBS::RUVFacetInfo& rfi, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcFacetAdminService__RqstNewRUVFacet_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcFacetAdminService__RqstNewRUVFacet_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcFacetAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcFacetAdminService*>(__delBase.get());
            return __del->RqstNewRUVFacet(rfi, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcFacetAdminService::begin_RqstNewRUVFacet(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcFacetAdminService__RqstNewRUVFacet_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcFacetAdminService__RqstNewRUVFacet_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcFacetAdminService__RqstNewRUVFacet_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcFacetAdminService::end_RqstNewRUVFacet(::iBS::RUVFacetInfo& rfi, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcFacetAdminService__RqstNewRUVFacet_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(rfi);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcFacetAdminService::RemoveRUVFacet(::Ice::Int facetID, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcFacetAdminService__RemoveRUVFacet_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcFacetAdminService__RemoveRUVFacet_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcFacetAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcFacetAdminService*>(__delBase.get());
            return __del->RemoveRUVFacet(facetID, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcFacetAdminService::begin_RemoveRUVFacet(::Ice::Int facetID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcFacetAdminService__RemoveRUVFacet_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcFacetAdminService__RemoveRUVFacet_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcFacetAdminService__RemoveRUVFacet_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(facetID);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcFacetAdminService::end_RemoveRUVFacet(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcFacetAdminService__RemoveRUVFacet_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcFacetAdminService::SetRUVFacetInfo(const ::iBS::RUVFacetInfo& rfi, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcFacetAdminService__SetRUVFacetInfo_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcFacetAdminService__SetRUVFacetInfo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcFacetAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcFacetAdminService*>(__delBase.get());
            return __del->SetRUVFacetInfo(rfi, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcFacetAdminService::begin_SetRUVFacetInfo(const ::iBS::RUVFacetInfo& rfi, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcFacetAdminService__SetRUVFacetInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcFacetAdminService__SetRUVFacetInfo_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcFacetAdminService__SetRUVFacetInfo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(rfi);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcFacetAdminService::end_SetRUVFacetInfo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcFacetAdminService__SetRUVFacetInfo_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::iBS::FcdcFacetAdminService::GetRUVFacetInfo(::Ice::Int facetID, ::iBS::RUVFacetInfo& rfi, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcFacetAdminService__GetRUVFacetInfo_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcFacetAdminService__GetRUVFacetInfo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcFacetAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcFacetAdminService*>(__delBase.get());
            return __del->GetRUVFacetInfo(facetID, rfi, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcFacetAdminService::begin_GetRUVFacetInfo(::Ice::Int facetID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcFacetAdminService__GetRUVFacetInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcFacetAdminService__GetRUVFacetInfo_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcFacetAdminService__GetRUVFacetInfo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(facetID);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::iBS::FcdcFacetAdminService::end_GetRUVFacetInfo(::iBS::RUVFacetInfo& rfi, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcFacetAdminService__GetRUVFacetInfo_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(rfi);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::iBS::FcdcRUVServicePrx
IceProxy::iBS::FcdcFacetAdminService::GetRUVFacet(::Ice::Int facetID, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcFacetAdminService__GetRUVFacet_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcFacetAdminService__GetRUVFacet_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcFacetAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcFacetAdminService*>(__delBase.get());
            return __del->GetRUVFacet(facetID, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcFacetAdminService::begin_GetRUVFacet(::Ice::Int facetID, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcFacetAdminService__GetRUVFacet_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcFacetAdminService__GetRUVFacet_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcFacetAdminService__GetRUVFacet_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(facetID);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::iBS::FcdcRUVServicePrx
IceProxy::iBS::FcdcFacetAdminService::end_GetRUVFacet(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcFacetAdminService__GetRUVFacet_name);
    ::iBS::FcdcRUVServicePrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::iBS::BigMatrixServicePrx
IceProxy::iBS::FcdcFacetAdminService::GetBigMatrixFacet(::Ice::Int gid, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __iBS__FcdcFacetAdminService__GetBigMatrixFacet_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__iBS__FcdcFacetAdminService__GetBigMatrixFacet_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::iBS::FcdcFacetAdminService* __del = dynamic_cast< ::IceDelegate::iBS::FcdcFacetAdminService*>(__delBase.get());
            return __del->GetBigMatrixFacet(gid, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::iBS::FcdcFacetAdminService::begin_GetBigMatrixFacet(::Ice::Int gid, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__iBS__FcdcFacetAdminService__GetBigMatrixFacet_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __iBS__FcdcFacetAdminService__GetBigMatrixFacet_name, __del, __cookie);
    try
    {
        __result->__prepare(__iBS__FcdcFacetAdminService__GetBigMatrixFacet_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(gid);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::iBS::BigMatrixServicePrx
IceProxy::iBS::FcdcFacetAdminService::end_GetBigMatrixFacet(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __iBS__FcdcFacetAdminService__GetBigMatrixFacet_name);
    ::iBS::BigMatrixServicePrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::iBS::FcdcFacetAdminService::ice_staticId()
{
    return ::iBS::FcdcFacetAdminService::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::iBS::FcdcFacetAdminService::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::iBS::FcdcFacetAdminService);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::iBS::FcdcFacetAdminService::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::iBS::FcdcFacetAdminService);
}

::IceProxy::Ice::Object*
IceProxy::iBS::FcdcFacetAdminService::__newInstance() const
{
    return new FcdcFacetAdminService;
}

::Ice::Int
IceDelegateM::iBS::ProxyCentralService::RegisterByCallerAdress(const ::std::string& servantName, const ::std::string& proxyStrNoHost, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__ProxyCentralService__RegisterByCallerAdress_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(servantName);
        __os->write(proxyStrNoHost);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::ProxyCentralService::RegisterByProxyStr(const ::std::string& servantName, const ::std::string& proxyStr, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__ProxyCentralService__RegisterByProxyStr_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(servantName);
        __os->write(proxyStr);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::ProxyCentralService::UnRegister(const ::std::string& servantName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__ProxyCentralService__UnRegister_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(servantName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::ProxyCentralService::UnRegisterAll(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__ProxyCentralService__UnRegisterAll_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::ProxyCentralService::ListAll(::iBS::StringVec& proxyStrs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__ProxyCentralService__ListAll_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(proxyStrs);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetFeatureDomains(const ::iBS::IntVec& domainIDs, ::iBS::FeatureDomainInfoVec& domainInfos, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetFeatureDomains_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(domainIDs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(domainInfos);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetFeatureObservers(const ::iBS::IntVec& observerIDs, ::iBS::FeatureObserverInfoVec& observerInfos, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetFeatureObservers_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(observerInfos);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetDoublesColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, ::iBS::DoubleVec& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetDoublesColumnVector_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(values);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetIntsColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, ::iBS::IntVec& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetIntsColumnVector_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(values);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetDoublesRowMatrix(::Ice::Int observerGroupID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, ::iBS::DoubleVec& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetDoublesRowMatrix_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerGroupID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(values);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetObserverStats(::Ice::Int observerID, ::iBS::ObserverStatsInfo& stats, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetObserverStats_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(stats);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetObserversStats(const ::iBS::IntVec& observerIDs, ::iBS::ObserverStatsInfoVec& observerStats, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetObserversStats_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(observerStats);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetRowMatrix(const ::iBS::IntVec& observerIDs, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const IceUtil::Optional< ::iBS::RowAdjustEnum>& rowAdjust, ::iBS::DoubleVec& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetRowMatrix_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(1, rowAdjust);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(values);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::SampleRowMatrix(const ::iBS::IntVec& observerIDs, const ::iBS::LongVec& featureIdxs, const IceUtil::Optional< ::iBS::RowAdjustEnum>& rowAdjust, ::iBS::DoubleVec& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__SampleRowMatrix_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __os->write(featureIdxs);
        __os->write(1, rowAdjust);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(values);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetObserverIndex(::Ice::Int observerID, ::iBS::ObserverIndexInfo& oii, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetObserverIndex_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(oii);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetFeatureIdxsByIntKeys(::Ice::Int observerID, const ::iBS::IntVec& keys, ::Ice::Long maxFeatureCnt, ::iBS::LongVec& featureIdxs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetFeatureIdxsByIntKeys_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(keys);
        __os->write(maxFeatureCnt);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(featureIdxs);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetFeatureCntsByIntKeys(::Ice::Int observerID, const ::iBS::IntVec& keys, ::iBS::LongVec& featureCnts, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetFeatureCntsByIntKeys_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(keys);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(featureCnts);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetAMDTaskInfo(::Ice::Long taskID, ::iBS::AMDTaskInfo& task, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetAMDTaskInfo_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(taskID);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(task);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetFeatureValueStoreDir(::std::string& rootDir, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetFeatureValueStoreDir_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(rootDir);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadService::GetFeatureValuePathPrefix(::Ice::Int observerID, ::std::string& pathPrefix, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadService__GetFeatureValuePathPrefix_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(pathPrefix);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadWriteService::SetFeatureDomains(const ::iBS::FeatureDomainInfoVec& domainInfos, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadWriteService__SetFeatureDomains_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(domainInfos);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadWriteService::SetFeatureObservers(const ::iBS::FeatureObserverInfoVec& observerInfos, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadWriteService__SetFeatureObservers_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerInfos);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadWriteService::SetDoublesColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadWriteService__SetDoublesColumnVector_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(values);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadWriteService::SetBytesColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& bytes, ::iBS::ByteArrayContentEnum content, ::iBS::ByteArrayEndianEnum endian, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadWriteService__SetBytesColumnVector_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(bytes);
        __os->write(content);
        __os->write(endian);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadWriteService::SetIntsColumnVector(::Ice::Int observerID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Int*, const ::Ice::Int*>& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadWriteService__SetIntsColumnVector_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(values);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcReadWriteService::SetDoublesRowMatrix(::Ice::Int observerGroupID, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcReadWriteService__SetDoublesRowMatrix_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerGroupID);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(values);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::iBS::FcdcAdminService::Shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__Shutdown_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcAdminService::RqstNewFeatureDomainID(::Ice::Int& domainID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__RqstNewFeatureDomainID_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(domainID);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcAdminService::RqstNewFeatureObserverID(bool inRAMNoSave, ::Ice::Int& observerID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__RqstNewFeatureObserverID_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inRAMNoSave);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(observerID);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcAdminService::RqstNewFeatureObserversInGroup(::Ice::Int groupSize, bool inRAMNoSave, ::iBS::IntVec& observerIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__RqstNewFeatureObserversInGroup_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(groupSize);
        __os->write(inRAMNoSave);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(observerIDs);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcAdminService::AttachBigMatrix(::Ice::Int colCnt, ::Ice::Long rowCnt, const ::iBS::StringVec& colNames, const ::std::string& storePathPrefix, ::iBS::IntVec& OIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__AttachBigMatrix_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(colCnt);
        __os->write(rowCnt);
        __os->write(colNames);
        __os->write(storePathPrefix);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(OIDs);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcAdminService::AttachBigVector(::Ice::Long rowCnt, const ::std::string& colName, const ::std::string& storePathPrefix, ::Ice::Int& OID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__AttachBigVector_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(rowCnt);
        __os->write(colName);
        __os->write(storePathPrefix);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(OID);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcAdminService::ForceLoadInRAM(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__ForceLoadInRAM_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcAdminService::ForceLeaveRAM(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__ForceLeaveRAM_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcAdminService::RecalculateObserverStats(const ::iBS::IntVec& observerIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__RecalculateObserverStats_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcAdminService::RecalculateObserverIndex(::Ice::Int observerID, bool saveIndexFile, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__RecalculateObserverIndex_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerID);
        __os->write(saveIndexFile);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcAdminService::RemoveFeatureObservers(const ::iBS::IntVec& observerIDs, bool removeDataFile, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__RemoveFeatureObservers_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __os->write(removeDataFile);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcAdminService::SetObserverStats(const ::iBS::ObserverStatsInfoVec& osis, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcAdminService__SetObserverStats_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(osis);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::SetActiveK(::Ice::Int k, ::Ice::Int extW, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__SetActiveK_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(k);
        __os->write(extW);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::SetOutputMode(::iBS::RUVOutputModeEnum mode, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__SetOutputMode_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(mode);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::SetOutputSamples(const ::iBS::IntVec& sampleIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__SetOutputSamples_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(sampleIDs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::ExcludeSamplesForGroupMean(const ::iBS::IntVec& excludeSampleIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__ExcludeSamplesForGroupMean_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(excludeSampleIDs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::SetOutputScale(::iBS::RUVOutputScaleEnum scale, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__SetOutputScale_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(scale);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::SetOutputWorkerNum(::Ice::Int workerNum, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__SetOutputWorkerNum_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(workerNum);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::SetCtrlQuantileValues(::Ice::Double quantile, const ::iBS::DoubleVec& qvalues, ::Ice::Double fration, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__SetCtrlQuantileValues_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(quantile);
        __os->write(qvalues);
        __os->write(fration);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::RebuildRUVModel(::Ice::Int threadCnt, ::Ice::Long ramMb, ::Ice::Long& taskID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__RebuildRUVModel_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(threadCnt);
        __os->write(ramMb);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(taskID);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::GetConditionIdxs(const ::iBS::IntVec& observerIDs, ::iBS::IntVec& conditionIdxs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__GetConditionIdxs_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(observerIDs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(conditionIdxs);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::GetConditionInfos(::iBS::ConditionInfoVec& conditions, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__GetConditionInfos_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(conditions);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::GetSamplesInGroups(const ::iBS::IntVec& sampleIDs, ::iBS::IntVecVec& groupSampleIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__GetSamplesInGroups_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(sampleIDs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(groupSampleIDs);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::GetG(::iBS::DoubleVec& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__GetG_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(values);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::GetWt(::iBS::DoubleVec& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__GetWt_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(values);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::GetEigenVals(::iBS::DoubleVec& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__GetEigenVals_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(values);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::SelectKByEigenVals(::Ice::Double minFraction, ::Ice::Int& k, ::iBS::DoubleVec& fractions, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__SelectKByEigenVals_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(minFraction);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(k);
        __is->read(fractions);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::DecomposeVariance(const ::iBS::IntVec& ks, const ::iBS::IntVec& extWs, const ::iBS::IntVecVec& wtVecIdxs, ::Ice::Long featureIdxFrom, ::Ice::Long featureIdxTo, ::Ice::Int threadCnt, ::Ice::Long ramMb, const ::std::string& outfile, ::iBS::RUVVarDecomposeInfoVec& vds, ::Ice::Long& taskID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__DecomposeVariance_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(ks);
        __os->write(extWs);
        __os->write(wtVecIdxs);
        __os->write(featureIdxFrom);
        __os->write(featureIdxTo);
        __os->write(threadCnt);
        __os->write(ramMb);
        __os->write(outfile);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(vds);
        __is->read(taskID);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcRUVService::SetWtVectorIdxs(const ::iBS::IntVec& vecIdxs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcRUVService__SetWtVectorIdxs_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(vecIdxs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::BigMatrixService::SetOutputSamples(const ::iBS::IntVec& sampleIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__BigMatrixService__SetOutputSamples_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(sampleIDs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::BigMatrixService::SetRowAdjust(::iBS::RowAdjustEnum rowAdjust, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__BigMatrixService__SetRowAdjust_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(rowAdjust);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::BigMatrixService::RecalculateObserverStats(::Ice::Long ramMb, ::Ice::Long& taskID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__BigMatrixService__RecalculateObserverStats_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(ramMb);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(taskID);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcFacetAdminService::RqstNewRUVFacet(::iBS::RUVFacetInfo& rfi, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcFacetAdminService__RqstNewRUVFacet_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(rfi);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcFacetAdminService::RemoveRUVFacet(::Ice::Int facetID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcFacetAdminService__RemoveRUVFacet_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(facetID);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcFacetAdminService::SetRUVFacetInfo(const ::iBS::RUVFacetInfo& rfi, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcFacetAdminService__SetRUVFacetInfo_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(rfi);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::iBS::FcdcFacetAdminService::GetRUVFacetInfo(::Ice::Int facetID, ::iBS::RUVFacetInfo& rfi, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcFacetAdminService__GetRUVFacetInfo_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(facetID);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(rfi);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::iBS::FcdcRUVServicePrx
IceDelegateM::iBS::FcdcFacetAdminService::GetRUVFacet(::Ice::Int facetID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcFacetAdminService__GetRUVFacet_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(facetID);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::iBS::FcdcRUVServicePrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::iBS::BigMatrixServicePrx
IceDelegateM::iBS::FcdcFacetAdminService::GetBigMatrixFacet(::Ice::Int gid, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __iBS__FcdcFacetAdminService__GetBigMatrixFacet_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(gid);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::iBS::BigMatrixServicePrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::iBS::ArgumentException&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateD::iBS::ProxyCentralService::RegisterByCallerAdress(const ::std::string& servantName, const ::std::string& proxyStrNoHost, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& __p_servantName, const ::std::string& __p_proxyStrNoHost, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_servantName(__p_servantName),
            _m_proxyStrNoHost(__p_proxyStrNoHost)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::ProxyCentralService* servant = dynamic_cast< ::iBS::ProxyCentralService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->RegisterByCallerAdress(_m_servantName, _m_proxyStrNoHost, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_servantName;
        const ::std::string& _m_proxyStrNoHost;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__ProxyCentralService__RegisterByCallerAdress_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, servantName, proxyStrNoHost, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::ProxyCentralService::RegisterByProxyStr(const ::std::string& servantName, const ::std::string& proxyStr, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& __p_servantName, const ::std::string& __p_proxyStr, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_servantName(__p_servantName),
            _m_proxyStr(__p_proxyStr)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::ProxyCentralService* servant = dynamic_cast< ::iBS::ProxyCentralService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->RegisterByProxyStr(_m_servantName, _m_proxyStr, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_servantName;
        const ::std::string& _m_proxyStr;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__ProxyCentralService__RegisterByProxyStr_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, servantName, proxyStr, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::ProxyCentralService::UnRegister(const ::std::string& servantName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& __p_servantName, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_servantName(__p_servantName)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::ProxyCentralService* servant = dynamic_cast< ::iBS::ProxyCentralService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->UnRegister(_m_servantName, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_servantName;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__ProxyCentralService__UnRegister_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, servantName, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::ProxyCentralService::UnRegisterAll(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::ProxyCentralService* servant = dynamic_cast< ::iBS::ProxyCentralService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->UnRegisterAll(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__ProxyCentralService__UnRegisterAll_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::ProxyCentralService::ListAll(::iBS::StringVec& proxyStrs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::iBS::StringVec& __p_proxyStrs, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_proxyStrs(__p_proxyStrs)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::ProxyCentralService* servant = dynamic_cast< ::iBS::ProxyCentralService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->ListAll(_m_proxyStrs, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::iBS::StringVec& _m_proxyStrs;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__ProxyCentralService__ListAll_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, proxyStrs, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetFeatureDomains(const ::iBS::IntVec& domainIDs, ::iBS::FeatureDomainInfoVec& domainInfos, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::IntVec& __p_domainIDs, ::iBS::FeatureDomainInfoVec& __p_domainInfos, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_domainIDs(__p_domainIDs),
            _m_domainInfos(__p_domainInfos)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcReadService* servant = dynamic_cast< ::iBS::FcdcReadService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetFeatureDomains(_m_domainIDs, _m_domainInfos, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::IntVec& _m_domainIDs;
        ::iBS::FeatureDomainInfoVec& _m_domainInfos;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcReadService__GetFeatureDomains_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, domainIDs, domainInfos, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetFeatureObservers(const ::iBS::IntVec& observerIDs, ::iBS::FeatureObserverInfoVec& observerInfos, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::IntVec& __p_observerIDs, ::iBS::FeatureObserverInfoVec& __p_observerInfos, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_observerIDs(__p_observerIDs),
            _m_observerInfos(__p_observerInfos)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcReadService* servant = dynamic_cast< ::iBS::FcdcReadService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetFeatureObservers(_m_observerIDs, _m_observerInfos, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::IntVec& _m_observerIDs;
        ::iBS::FeatureObserverInfoVec& _m_observerInfos;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcReadService__GetFeatureObservers_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, observerIDs, observerInfos, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetDoublesColumnVector(::Ice::Int, ::Ice::Long, ::Ice::Long, ::iBS::DoubleVec&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetIntsColumnVector(::Ice::Int, ::Ice::Long, ::Ice::Long, ::iBS::IntVec&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetDoublesRowMatrix(::Ice::Int, ::Ice::Long, ::Ice::Long, ::iBS::DoubleVec&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetObserverStats(::Ice::Int observerID, ::iBS::ObserverStatsInfo& stats, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_observerID, ::iBS::ObserverStatsInfo& __p_stats, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_observerID(__p_observerID),
            _m_stats(__p_stats)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcReadService* servant = dynamic_cast< ::iBS::FcdcReadService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetObserverStats(_m_observerID, _m_stats, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_observerID;
        ::iBS::ObserverStatsInfo& _m_stats;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcReadService__GetObserverStats_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, observerID, stats, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetObserversStats(const ::iBS::IntVec& observerIDs, ::iBS::ObserverStatsInfoVec& observerStats, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::IntVec& __p_observerIDs, ::iBS::ObserverStatsInfoVec& __p_observerStats, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_observerIDs(__p_observerIDs),
            _m_observerStats(__p_observerStats)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcReadService* servant = dynamic_cast< ::iBS::FcdcReadService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetObserversStats(_m_observerIDs, _m_observerStats, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::IntVec& _m_observerIDs;
        ::iBS::ObserverStatsInfoVec& _m_observerStats;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcReadService__GetObserversStats_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, observerIDs, observerStats, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetRowMatrix(const ::iBS::IntVec&, ::Ice::Long, ::Ice::Long, const IceUtil::Optional< ::iBS::RowAdjustEnum>&, ::iBS::DoubleVec&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::SampleRowMatrix(const ::iBS::IntVec&, const ::iBS::LongVec&, const IceUtil::Optional< ::iBS::RowAdjustEnum>&, ::iBS::DoubleVec&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetObserverIndex(::Ice::Int observerID, ::iBS::ObserverIndexInfo& oii, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_observerID, ::iBS::ObserverIndexInfo& __p_oii, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_observerID(__p_observerID),
            _m_oii(__p_oii)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcReadService* servant = dynamic_cast< ::iBS::FcdcReadService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetObserverIndex(_m_observerID, _m_oii, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_observerID;
        ::iBS::ObserverIndexInfo& _m_oii;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcReadService__GetObserverIndex_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, observerID, oii, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetFeatureIdxsByIntKeys(::Ice::Int, const ::iBS::IntVec&, ::Ice::Long, ::iBS::LongVec&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetFeatureCntsByIntKeys(::Ice::Int, const ::iBS::IntVec&, ::iBS::LongVec&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetAMDTaskInfo(::Ice::Long taskID, ::iBS::AMDTaskInfo& task, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Long __p_taskID, ::iBS::AMDTaskInfo& __p_task, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_taskID(__p_taskID),
            _m_task(__p_task)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcReadService* servant = dynamic_cast< ::iBS::FcdcReadService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetAMDTaskInfo(_m_taskID, _m_task, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Long _m_taskID;
        ::iBS::AMDTaskInfo& _m_task;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcReadService__GetAMDTaskInfo_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, taskID, task, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetFeatureValueStoreDir(::std::string& rootDir, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::std::string& __p_rootDir, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_rootDir(__p_rootDir)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcReadService* servant = dynamic_cast< ::iBS::FcdcReadService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetFeatureValueStoreDir(_m_rootDir, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::std::string& _m_rootDir;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcReadService__GetFeatureValueStoreDir_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, rootDir, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadService::GetFeatureValuePathPrefix(::Ice::Int observerID, ::std::string& pathPrefix, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_observerID, ::std::string& __p_pathPrefix, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_observerID(__p_observerID),
            _m_pathPrefix(__p_pathPrefix)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcReadService* servant = dynamic_cast< ::iBS::FcdcReadService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetFeatureValuePathPrefix(_m_observerID, _m_pathPrefix, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_observerID;
        ::std::string& _m_pathPrefix;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcReadService__GetFeatureValuePathPrefix_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, observerID, pathPrefix, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadWriteService::SetFeatureDomains(const ::iBS::FeatureDomainInfoVec& domainInfos, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::FeatureDomainInfoVec& __p_domainInfos, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_domainInfos(__p_domainInfos)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcReadWriteService* servant = dynamic_cast< ::iBS::FcdcReadWriteService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SetFeatureDomains(_m_domainInfos, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::FeatureDomainInfoVec& _m_domainInfos;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcReadWriteService__SetFeatureDomains_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, domainInfos, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadWriteService::SetFeatureObservers(const ::iBS::FeatureObserverInfoVec& observerInfos, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::FeatureObserverInfoVec& __p_observerInfos, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_observerInfos(__p_observerInfos)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcReadWriteService* servant = dynamic_cast< ::iBS::FcdcReadWriteService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SetFeatureObservers(_m_observerInfos, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::FeatureObserverInfoVec& _m_observerInfos;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcReadWriteService__SetFeatureObservers_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, observerInfos, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadWriteService::SetDoublesColumnVector(::Ice::Int, ::Ice::Long, ::Ice::Long, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadWriteService::SetBytesColumnVector(::Ice::Int, ::Ice::Long, ::Ice::Long, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>&, ::iBS::ByteArrayContentEnum, ::iBS::ByteArrayEndianEnum, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadWriteService::SetIntsColumnVector(::Ice::Int, ::Ice::Long, ::Ice::Long, const ::std::pair<const ::Ice::Int*, const ::Ice::Int*>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcReadWriteService::SetDoublesRowMatrix(::Ice::Int, ::Ice::Long, ::Ice::Long, const ::std::pair<const ::Ice::Double*, const ::Ice::Double*>&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

void
IceDelegateD::iBS::FcdcAdminService::Shutdown(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcAdminService* servant = dynamic_cast< ::iBS::FcdcAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->Shutdown(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcAdminService__Shutdown_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::iBS::FcdcAdminService::RqstNewFeatureDomainID(::Ice::Int& domainID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int& __p_domainID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_domainID(__p_domainID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcAdminService* servant = dynamic_cast< ::iBS::FcdcAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->RqstNewFeatureDomainID(_m_domainID, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int& _m_domainID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcAdminService__RqstNewFeatureDomainID_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, domainID, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcAdminService::RqstNewFeatureObserverID(bool inRAMNoSave, ::Ice::Int& observerID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, bool __p_inRAMNoSave, ::Ice::Int& __p_observerID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inRAMNoSave(__p_inRAMNoSave),
            _m_observerID(__p_observerID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcAdminService* servant = dynamic_cast< ::iBS::FcdcAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->RqstNewFeatureObserverID(_m_inRAMNoSave, _m_observerID, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        bool _m_inRAMNoSave;
        ::Ice::Int& _m_observerID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcAdminService__RqstNewFeatureObserverID_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, inRAMNoSave, observerID, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcAdminService::RqstNewFeatureObserversInGroup(::Ice::Int groupSize, bool inRAMNoSave, ::iBS::IntVec& observerIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_groupSize, bool __p_inRAMNoSave, ::iBS::IntVec& __p_observerIDs, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_groupSize(__p_groupSize),
            _m_inRAMNoSave(__p_inRAMNoSave),
            _m_observerIDs(__p_observerIDs)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcAdminService* servant = dynamic_cast< ::iBS::FcdcAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->RqstNewFeatureObserversInGroup(_m_groupSize, _m_inRAMNoSave, _m_observerIDs, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_groupSize;
        bool _m_inRAMNoSave;
        ::iBS::IntVec& _m_observerIDs;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcAdminService__RqstNewFeatureObserversInGroup_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, groupSize, inRAMNoSave, observerIDs, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcAdminService::AttachBigMatrix(::Ice::Int colCnt, ::Ice::Long rowCnt, const ::iBS::StringVec& colNames, const ::std::string& storePathPrefix, ::iBS::IntVec& OIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_colCnt, ::Ice::Long __p_rowCnt, const ::iBS::StringVec& __p_colNames, const ::std::string& __p_storePathPrefix, ::iBS::IntVec& __p_OIDs, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_colCnt(__p_colCnt),
            _m_rowCnt(__p_rowCnt),
            _m_colNames(__p_colNames),
            _m_storePathPrefix(__p_storePathPrefix),
            _m_OIDs(__p_OIDs)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcAdminService* servant = dynamic_cast< ::iBS::FcdcAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->AttachBigMatrix(_m_colCnt, _m_rowCnt, _m_colNames, _m_storePathPrefix, _m_OIDs, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_colCnt;
        ::Ice::Long _m_rowCnt;
        const ::iBS::StringVec& _m_colNames;
        const ::std::string& _m_storePathPrefix;
        ::iBS::IntVec& _m_OIDs;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcAdminService__AttachBigMatrix_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, colCnt, rowCnt, colNames, storePathPrefix, OIDs, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcAdminService::AttachBigVector(::Ice::Long rowCnt, const ::std::string& colName, const ::std::string& storePathPrefix, ::Ice::Int& OID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Long __p_rowCnt, const ::std::string& __p_colName, const ::std::string& __p_storePathPrefix, ::Ice::Int& __p_OID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_rowCnt(__p_rowCnt),
            _m_colName(__p_colName),
            _m_storePathPrefix(__p_storePathPrefix),
            _m_OID(__p_OID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcAdminService* servant = dynamic_cast< ::iBS::FcdcAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->AttachBigVector(_m_rowCnt, _m_colName, _m_storePathPrefix, _m_OID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Long _m_rowCnt;
        const ::std::string& _m_colName;
        const ::std::string& _m_storePathPrefix;
        ::Ice::Int& _m_OID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcAdminService__AttachBigVector_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, rowCnt, colName, storePathPrefix, OID, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcAdminService::ForceLoadInRAM(const ::iBS::IntVec&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcAdminService::ForceLeaveRAM(const ::iBS::IntVec&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcAdminService::RecalculateObserverStats(const ::iBS::IntVec&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcAdminService::RecalculateObserverIndex(::Ice::Int, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcAdminService::RemoveFeatureObservers(const ::iBS::IntVec&, bool, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcAdminService::SetObserverStats(const ::iBS::ObserverStatsInfoVec& osis, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::ObserverStatsInfoVec& __p_osis, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_osis(__p_osis)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcAdminService* servant = dynamic_cast< ::iBS::FcdcAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SetObserverStats(_m_osis, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::ObserverStatsInfoVec& _m_osis;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcAdminService__SetObserverStats_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, osis, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::SetActiveK(::Ice::Int, ::Ice::Int, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::SetOutputMode(::iBS::RUVOutputModeEnum mode, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::iBS::RUVOutputModeEnum __p_mode, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_mode(__p_mode)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SetOutputMode(_m_mode, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::iBS::RUVOutputModeEnum _m_mode;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__SetOutputMode_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, mode, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::SetOutputSamples(const ::iBS::IntVec& sampleIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::IntVec& __p_sampleIDs, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_sampleIDs(__p_sampleIDs)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SetOutputSamples(_m_sampleIDs, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::IntVec& _m_sampleIDs;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__SetOutputSamples_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, sampleIDs, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::ExcludeSamplesForGroupMean(const ::iBS::IntVec& excludeSampleIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::IntVec& __p_excludeSampleIDs, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_excludeSampleIDs(__p_excludeSampleIDs)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->ExcludeSamplesForGroupMean(_m_excludeSampleIDs, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::IntVec& _m_excludeSampleIDs;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__ExcludeSamplesForGroupMean_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, excludeSampleIDs, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::SetOutputScale(::iBS::RUVOutputScaleEnum scale, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::iBS::RUVOutputScaleEnum __p_scale, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_scale(__p_scale)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SetOutputScale(_m_scale, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::iBS::RUVOutputScaleEnum _m_scale;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__SetOutputScale_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, scale, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::SetOutputWorkerNum(::Ice::Int workerNum, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_workerNum, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_workerNum(__p_workerNum)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SetOutputWorkerNum(_m_workerNum, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_workerNum;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__SetOutputWorkerNum_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, workerNum, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::SetCtrlQuantileValues(::Ice::Double quantile, const ::iBS::DoubleVec& qvalues, ::Ice::Double fration, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Double __p_quantile, const ::iBS::DoubleVec& __p_qvalues, ::Ice::Double __p_fration, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_quantile(__p_quantile),
            _m_qvalues(__p_qvalues),
            _m_fration(__p_fration)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->SetCtrlQuantileValues(_m_quantile, _m_qvalues, _m_fration, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Double _m_quantile;
        const ::iBS::DoubleVec& _m_qvalues;
        ::Ice::Double _m_fration;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__SetCtrlQuantileValues_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, quantile, qvalues, fration, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::RebuildRUVModel(::Ice::Int, ::Ice::Long, ::Ice::Long&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::GetConditionIdxs(const ::iBS::IntVec& observerIDs, ::iBS::IntVec& conditionIdxs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::IntVec& __p_observerIDs, ::iBS::IntVec& __p_conditionIdxs, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_observerIDs(__p_observerIDs),
            _m_conditionIdxs(__p_conditionIdxs)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetConditionIdxs(_m_observerIDs, _m_conditionIdxs, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::IntVec& _m_observerIDs;
        ::iBS::IntVec& _m_conditionIdxs;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__GetConditionIdxs_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, observerIDs, conditionIdxs, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::GetConditionInfos(::iBS::ConditionInfoVec& conditions, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::iBS::ConditionInfoVec& __p_conditions, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_conditions(__p_conditions)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetConditionInfos(_m_conditions, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::iBS::ConditionInfoVec& _m_conditions;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__GetConditionInfos_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, conditions, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::GetSamplesInGroups(const ::iBS::IntVec& sampleIDs, ::iBS::IntVecVec& groupSampleIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::IntVec& __p_sampleIDs, ::iBS::IntVecVec& __p_groupSampleIDs, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_sampleIDs(__p_sampleIDs),
            _m_groupSampleIDs(__p_groupSampleIDs)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetSamplesInGroups(_m_sampleIDs, _m_groupSampleIDs, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::IntVec& _m_sampleIDs;
        ::iBS::IntVecVec& _m_groupSampleIDs;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__GetSamplesInGroups_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, sampleIDs, groupSampleIDs, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::GetG(::iBS::DoubleVec& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::iBS::DoubleVec& __p_values, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_values(__p_values)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetG(_m_values, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::iBS::DoubleVec& _m_values;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__GetG_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, values, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::GetWt(::iBS::DoubleVec& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::iBS::DoubleVec& __p_values, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_values(__p_values)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetWt(_m_values, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::iBS::DoubleVec& _m_values;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__GetWt_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, values, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::GetEigenVals(::iBS::DoubleVec& values, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::iBS::DoubleVec& __p_values, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_values(__p_values)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetEigenVals(_m_values, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::iBS::DoubleVec& _m_values;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__GetEigenVals_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, values, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::SelectKByEigenVals(::Ice::Double minFraction, ::Ice::Int& k, ::iBS::DoubleVec& fractions, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Double __p_minFraction, ::Ice::Int& __p_k, ::iBS::DoubleVec& __p_fractions, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_minFraction(__p_minFraction),
            _m_k(__p_k),
            _m_fractions(__p_fractions)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SelectKByEigenVals(_m_minFraction, _m_k, _m_fractions, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Double _m_minFraction;
        ::Ice::Int& _m_k;
        ::iBS::DoubleVec& _m_fractions;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__SelectKByEigenVals_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, minFraction, k, fractions, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::DecomposeVariance(const ::iBS::IntVec&, const ::iBS::IntVec&, const ::iBS::IntVecVec&, ::Ice::Long, ::Ice::Long, ::Ice::Int, ::Ice::Long, const ::std::string&, ::iBS::RUVVarDecomposeInfoVec&, ::Ice::Long&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcRUVService::SetWtVectorIdxs(const ::iBS::IntVec& vecIdxs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::IntVec& __p_vecIdxs, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_vecIdxs(__p_vecIdxs)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcRUVService* servant = dynamic_cast< ::iBS::FcdcRUVService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SetWtVectorIdxs(_m_vecIdxs, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::IntVec& _m_vecIdxs;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcRUVService__SetWtVectorIdxs_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, vecIdxs, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::BigMatrixService::SetOutputSamples(const ::iBS::IntVec& sampleIDs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::IntVec& __p_sampleIDs, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_sampleIDs(__p_sampleIDs)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::BigMatrixService* servant = dynamic_cast< ::iBS::BigMatrixService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SetOutputSamples(_m_sampleIDs, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::IntVec& _m_sampleIDs;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__BigMatrixService__SetOutputSamples_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, sampleIDs, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::BigMatrixService::SetRowAdjust(::iBS::RowAdjustEnum rowAdjust, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::iBS::RowAdjustEnum __p_rowAdjust, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_rowAdjust(__p_rowAdjust)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::BigMatrixService* servant = dynamic_cast< ::iBS::BigMatrixService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SetRowAdjust(_m_rowAdjust, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::iBS::RowAdjustEnum _m_rowAdjust;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__BigMatrixService__SetRowAdjust_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, rowAdjust, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::BigMatrixService::RecalculateObserverStats(::Ice::Long, ::Ice::Long&, const ::Ice::Context*, ::IceInternal::InvocationObserver&)
{
    throw ::Ice::CollocationOptimizationException(__FILE__, __LINE__);
    return ::Ice::Int(); // to avoid a warning with some compilers;
}

::Ice::Int
IceDelegateD::iBS::FcdcFacetAdminService::RqstNewRUVFacet(::iBS::RUVFacetInfo& rfi, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::iBS::RUVFacetInfo& __p_rfi, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_rfi(__p_rfi)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcFacetAdminService* servant = dynamic_cast< ::iBS::FcdcFacetAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->RqstNewRUVFacet(_m_rfi, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::iBS::RUVFacetInfo& _m_rfi;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcFacetAdminService__RqstNewRUVFacet_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, rfi, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcFacetAdminService::RemoveRUVFacet(::Ice::Int facetID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_facetID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_facetID(__p_facetID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcFacetAdminService* servant = dynamic_cast< ::iBS::FcdcFacetAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->RemoveRUVFacet(_m_facetID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_facetID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcFacetAdminService__RemoveRUVFacet_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, facetID, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcFacetAdminService::SetRUVFacetInfo(const ::iBS::RUVFacetInfo& rfi, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::iBS::RUVFacetInfo& __p_rfi, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_rfi(__p_rfi)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcFacetAdminService* servant = dynamic_cast< ::iBS::FcdcFacetAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->SetRUVFacetInfo(_m_rfi, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::iBS::RUVFacetInfo& _m_rfi;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcFacetAdminService__SetRUVFacetInfo_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, rfi, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::iBS::FcdcFacetAdminService::GetRUVFacetInfo(::Ice::Int facetID, ::iBS::RUVFacetInfo& rfi, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_facetID, ::iBS::RUVFacetInfo& __p_rfi, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_facetID(__p_facetID),
            _m_rfi(__p_rfi)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcFacetAdminService* servant = dynamic_cast< ::iBS::FcdcFacetAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetRUVFacetInfo(_m_facetID, _m_rfi, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_facetID;
        ::iBS::RUVFacetInfo& _m_rfi;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcFacetAdminService__GetRUVFacetInfo_name, ::Ice::Normal, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, facetID, rfi, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::iBS::FcdcRUVServicePrx
IceDelegateD::iBS::FcdcFacetAdminService::GetRUVFacet(::Ice::Int facetID, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::iBS::FcdcRUVServicePrx& __result, ::Ice::Int __p_facetID, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_facetID(__p_facetID)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcFacetAdminService* servant = dynamic_cast< ::iBS::FcdcFacetAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetRUVFacet(_m_facetID, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::iBS::FcdcRUVServicePrx& _result;
        ::Ice::Int _m_facetID;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcFacetAdminService__GetRUVFacet_name, ::Ice::Normal, __context);
    ::iBS::FcdcRUVServicePrx __result;
    try
    {
        _DirectI __direct(__result, facetID, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::iBS::BigMatrixServicePrx
IceDelegateD::iBS::FcdcFacetAdminService::GetBigMatrixFacet(::Ice::Int gid, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::iBS::BigMatrixServicePrx& __result, ::Ice::Int __p_gid, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_gid(__p_gid)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::iBS::FcdcFacetAdminService* servant = dynamic_cast< ::iBS::FcdcFacetAdminService*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetBigMatrixFacet(_m_gid, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::iBS::BigMatrixServicePrx& _result;
        ::Ice::Int _m_gid;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __iBS__FcdcFacetAdminService__GetBigMatrixFacet_name, ::Ice::Normal, __context);
    ::iBS::BigMatrixServicePrx __result;
    try
    {
        _DirectI __direct(__result, gid, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::iBS::ArgumentException&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Object* iBS::upCast(::iBS::ProxyCentralService* p) { return p; }

namespace
{
const ::std::string __iBS__ProxyCentralService_ids[2] =
{
    "::Ice::Object",
    "::iBS::ProxyCentralService"
};

}

bool
iBS::ProxyCentralService::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__iBS__ProxyCentralService_ids, __iBS__ProxyCentralService_ids + 2, _s);
}

::std::vector< ::std::string>
iBS::ProxyCentralService::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__iBS__ProxyCentralService_ids[0], &__iBS__ProxyCentralService_ids[2]);
}

const ::std::string&
iBS::ProxyCentralService::ice_id(const ::Ice::Current&) const
{
    return __iBS__ProxyCentralService_ids[1];
}

const ::std::string&
iBS::ProxyCentralService::ice_staticId()
{
    return __iBS__ProxyCentralService_ids[1];
}

::Ice::DispatchStatus
iBS::ProxyCentralService::___RegisterByCallerAdress(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string servantName;
    ::std::string proxyStrNoHost;
    __is->read(servantName);
    __is->read(proxyStrNoHost);
    __inS.endReadParams();
    ::Ice::Int __ret = RegisterByCallerAdress(servantName, proxyStrNoHost, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
iBS::ProxyCentralService::___RegisterByProxyStr(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string servantName;
    ::std::string proxyStr;
    __is->read(servantName);
    __is->read(proxyStr);
    __inS.endReadParams();
    ::Ice::Int __ret = RegisterByProxyStr(servantName, proxyStr, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
iBS::ProxyCentralService::___UnRegister(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string servantName;
    __is->read(servantName);
    __inS.endReadParams();
    ::Ice::Int __ret = UnRegister(servantName, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
iBS::ProxyCentralService::___UnRegisterAll(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Int __ret = UnRegisterAll(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
iBS::ProxyCentralService::___ListAll(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::iBS::StringVec proxyStrs;
    ::Ice::Int __ret = ListAll(proxyStrs, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(proxyStrs);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __iBS__ProxyCentralService_all[] =
{
    "ListAll",
    "RegisterByCallerAdress",
    "RegisterByProxyStr",
    "UnRegister",
    "UnRegisterAll",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
iBS::ProxyCentralService::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__iBS__ProxyCentralService_all, __iBS__ProxyCentralService_all + 9, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __iBS__ProxyCentralService_all)
    {
        case 0:
        {
            return ___ListAll(in, current);
        }
        case 1:
        {
            return ___RegisterByCallerAdress(in, current);
        }
        case 2:
        {
            return ___RegisterByProxyStr(in, current);
        }
        case 3:
        {
            return ___UnRegister(in, current);
        }
        case 4:
        {
            return ___UnRegisterAll(in, current);
        }
        case 5:
        {
            return ___ice_id(in, current);
        }
        case 6:
        {
            return ___ice_ids(in, current);
        }
        case 7:
        {
            return ___ice_isA(in, current);
        }
        case 8:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
iBS::ProxyCentralService::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
iBS::ProxyCentralService::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
iBS::__patch(ProxyCentralServicePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::iBS::ProxyCentralServicePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::iBS::ProxyCentralService::ice_staticId(), v);
    }
}

::Ice::Object* iBS::upCast(::iBS::FcdcReadService* p) { return p; }

namespace
{
const ::std::string __iBS__FcdcReadService_ids[2] =
{
    "::Ice::Object",
    "::iBS::FcdcReadService"
};

}

bool
iBS::FcdcReadService::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__iBS__FcdcReadService_ids, __iBS__FcdcReadService_ids + 2, _s);
}

::std::vector< ::std::string>
iBS::FcdcReadService::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__iBS__FcdcReadService_ids[0], &__iBS__FcdcReadService_ids[2]);
}

const ::std::string&
iBS::FcdcReadService::ice_id(const ::Ice::Current&) const
{
    return __iBS__FcdcReadService_ids[1];
}

const ::std::string&
iBS::FcdcReadService::ice_staticId()
{
    return __iBS__FcdcReadService_ids[1];
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetFeatureDomains(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec domainIDs;
    __is->read(domainIDs);
    __inS.endReadParams();
    ::iBS::FeatureDomainInfoVec domainInfos;
    try
    {
        ::Ice::Int __ret = GetFeatureDomains(domainIDs, domainInfos, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(domainInfos);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetFeatureObservers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec observerIDs;
    __is->read(observerIDs);
    __inS.endReadParams();
    ::iBS::FeatureObserverInfoVec observerInfos;
    try
    {
        ::Ice::Int __ret = GetFeatureObservers(observerIDs, observerInfos, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerInfos);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetDoublesColumnVector(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerID;
    ::Ice::Long featureIdxFrom;
    ::Ice::Long featureIdxTo;
    __is->read(observerID);
    __is->read(featureIdxFrom);
    __is->read(featureIdxTo);
    __inS.endReadParams();
    ::iBS::AMD_FcdcReadService_GetDoublesColumnVectorPtr __cb = new IceAsync::iBS::AMD_FcdcReadService_GetDoublesColumnVector(__inS);
    try
    {
        GetDoublesColumnVector_async(__cb, observerID, featureIdxFrom, featureIdxTo, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetIntsColumnVector(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerID;
    ::Ice::Long featureIdxFrom;
    ::Ice::Long featureIdxTo;
    __is->read(observerID);
    __is->read(featureIdxFrom);
    __is->read(featureIdxTo);
    __inS.endReadParams();
    ::iBS::AMD_FcdcReadService_GetIntsColumnVectorPtr __cb = new IceAsync::iBS::AMD_FcdcReadService_GetIntsColumnVector(__inS);
    try
    {
        GetIntsColumnVector_async(__cb, observerID, featureIdxFrom, featureIdxTo, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetDoublesRowMatrix(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerGroupID;
    ::Ice::Long featureIdxFrom;
    ::Ice::Long featureIdxTo;
    __is->read(observerGroupID);
    __is->read(featureIdxFrom);
    __is->read(featureIdxTo);
    __inS.endReadParams();
    ::iBS::AMD_FcdcReadService_GetDoublesRowMatrixPtr __cb = new IceAsync::iBS::AMD_FcdcReadService_GetDoublesRowMatrix(__inS);
    try
    {
        GetDoublesRowMatrix_async(__cb, observerGroupID, featureIdxFrom, featureIdxTo, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetObserverStats(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerID;
    __is->read(observerID);
    __inS.endReadParams();
    ::iBS::ObserverStatsInfo stats;
    try
    {
        ::Ice::Int __ret = GetObserverStats(observerID, stats, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(stats);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetObserversStats(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec observerIDs;
    __is->read(observerIDs);
    __inS.endReadParams();
    ::iBS::ObserverStatsInfoVec observerStats;
    try
    {
        ::Ice::Int __ret = GetObserversStats(observerIDs, observerStats, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(observerStats);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetRowMatrix(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec observerIDs;
    ::Ice::Long featureIdxFrom;
    ::Ice::Long featureIdxTo;
    IceUtil::Optional< ::iBS::RowAdjustEnum> rowAdjust;
    __is->read(observerIDs);
    __is->read(featureIdxFrom);
    __is->read(featureIdxTo);
    __is->read(1, rowAdjust);
    __inS.endReadParams();
    ::iBS::AMD_FcdcReadService_GetRowMatrixPtr __cb = new IceAsync::iBS::AMD_FcdcReadService_GetRowMatrix(__inS);
    try
    {
        GetRowMatrix_async(__cb, observerIDs, featureIdxFrom, featureIdxTo, rowAdjust, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___SampleRowMatrix(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec observerIDs;
    ::iBS::LongVec featureIdxs;
    IceUtil::Optional< ::iBS::RowAdjustEnum> rowAdjust;
    __is->read(observerIDs);
    __is->read(featureIdxs);
    __is->read(1, rowAdjust);
    __inS.endReadParams();
    ::iBS::AMD_FcdcReadService_SampleRowMatrixPtr __cb = new IceAsync::iBS::AMD_FcdcReadService_SampleRowMatrix(__inS);
    try
    {
        SampleRowMatrix_async(__cb, observerIDs, featureIdxs, rowAdjust, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetObserverIndex(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerID;
    __is->read(observerID);
    __inS.endReadParams();
    ::iBS::ObserverIndexInfo oii;
    try
    {
        ::Ice::Int __ret = GetObserverIndex(observerID, oii, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(oii);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetFeatureIdxsByIntKeys(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerID;
    ::iBS::IntVec keys;
    ::Ice::Long maxFeatureCnt;
    __is->read(observerID);
    __is->read(keys);
    __is->read(maxFeatureCnt);
    __inS.endReadParams();
    ::iBS::AMD_FcdcReadService_GetFeatureIdxsByIntKeysPtr __cb = new IceAsync::iBS::AMD_FcdcReadService_GetFeatureIdxsByIntKeys(__inS);
    try
    {
        GetFeatureIdxsByIntKeys_async(__cb, observerID, keys, maxFeatureCnt, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetFeatureCntsByIntKeys(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerID;
    ::iBS::IntVec keys;
    __is->read(observerID);
    __is->read(keys);
    __inS.endReadParams();
    ::iBS::AMD_FcdcReadService_GetFeatureCntsByIntKeysPtr __cb = new IceAsync::iBS::AMD_FcdcReadService_GetFeatureCntsByIntKeys(__inS);
    try
    {
        GetFeatureCntsByIntKeys_async(__cb, observerID, keys, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetAMDTaskInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Long taskID;
    __is->read(taskID);
    __inS.endReadParams();
    ::iBS::AMDTaskInfo task;
    try
    {
        ::Ice::Int __ret = GetAMDTaskInfo(taskID, task, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(task);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetFeatureValueStoreDir(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::std::string rootDir;
    try
    {
        ::Ice::Int __ret = GetFeatureValueStoreDir(rootDir, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(rootDir);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcReadService::___GetFeatureValuePathPrefix(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerID;
    __is->read(observerID);
    __inS.endReadParams();
    ::std::string pathPrefix;
    try
    {
        ::Ice::Int __ret = GetFeatureValuePathPrefix(observerID, pathPrefix, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(pathPrefix);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __iBS__FcdcReadService_all[] =
{
    "GetAMDTaskInfo",
    "GetDoublesColumnVector",
    "GetDoublesRowMatrix",
    "GetFeatureCntsByIntKeys",
    "GetFeatureDomains",
    "GetFeatureIdxsByIntKeys",
    "GetFeatureObservers",
    "GetFeatureValuePathPrefix",
    "GetFeatureValueStoreDir",
    "GetIntsColumnVector",
    "GetObserverIndex",
    "GetObserverStats",
    "GetObserversStats",
    "GetRowMatrix",
    "SampleRowMatrix",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
iBS::FcdcReadService::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__iBS__FcdcReadService_all, __iBS__FcdcReadService_all + 19, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __iBS__FcdcReadService_all)
    {
        case 0:
        {
            return ___GetAMDTaskInfo(in, current);
        }
        case 1:
        {
            return ___GetDoublesColumnVector(in, current);
        }
        case 2:
        {
            return ___GetDoublesRowMatrix(in, current);
        }
        case 3:
        {
            return ___GetFeatureCntsByIntKeys(in, current);
        }
        case 4:
        {
            return ___GetFeatureDomains(in, current);
        }
        case 5:
        {
            return ___GetFeatureIdxsByIntKeys(in, current);
        }
        case 6:
        {
            return ___GetFeatureObservers(in, current);
        }
        case 7:
        {
            return ___GetFeatureValuePathPrefix(in, current);
        }
        case 8:
        {
            return ___GetFeatureValueStoreDir(in, current);
        }
        case 9:
        {
            return ___GetIntsColumnVector(in, current);
        }
        case 10:
        {
            return ___GetObserverIndex(in, current);
        }
        case 11:
        {
            return ___GetObserverStats(in, current);
        }
        case 12:
        {
            return ___GetObserversStats(in, current);
        }
        case 13:
        {
            return ___GetRowMatrix(in, current);
        }
        case 14:
        {
            return ___SampleRowMatrix(in, current);
        }
        case 15:
        {
            return ___ice_id(in, current);
        }
        case 16:
        {
            return ___ice_ids(in, current);
        }
        case 17:
        {
            return ___ice_isA(in, current);
        }
        case 18:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
iBS::FcdcReadService::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
iBS::FcdcReadService::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
iBS::__patch(FcdcReadServicePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::iBS::FcdcReadServicePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::iBS::FcdcReadService::ice_staticId(), v);
    }
}

::Ice::Object* iBS::upCast(::iBS::FcdcReadWriteService* p) { return p; }

namespace
{
const ::std::string __iBS__FcdcReadWriteService_ids[3] =
{
    "::Ice::Object",
    "::iBS::FcdcReadService",
    "::iBS::FcdcReadWriteService"
};

}

bool
iBS::FcdcReadWriteService::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__iBS__FcdcReadWriteService_ids, __iBS__FcdcReadWriteService_ids + 3, _s);
}

::std::vector< ::std::string>
iBS::FcdcReadWriteService::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__iBS__FcdcReadWriteService_ids[0], &__iBS__FcdcReadWriteService_ids[3]);
}

const ::std::string&
iBS::FcdcReadWriteService::ice_id(const ::Ice::Current&) const
{
    return __iBS__FcdcReadWriteService_ids[2];
}

const ::std::string&
iBS::FcdcReadWriteService::ice_staticId()
{
    return __iBS__FcdcReadWriteService_ids[2];
}

::Ice::DispatchStatus
iBS::FcdcReadWriteService::___SetFeatureDomains(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::FeatureDomainInfoVec domainInfos;
    __is->read(domainInfos);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = SetFeatureDomains(domainInfos, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcReadWriteService::___SetFeatureObservers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::FeatureObserverInfoVec observerInfos;
    __is->read(observerInfos);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = SetFeatureObservers(observerInfos, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcReadWriteService::___SetDoublesColumnVector(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerID;
    ::Ice::Long featureIdxFrom;
    ::Ice::Long featureIdxTo;
    ::std::pair<const ::Ice::Double*, const ::Ice::Double*> values;
    ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > ___values;
    __is->read(observerID);
    __is->read(featureIdxFrom);
    __is->read(featureIdxTo);
    __is->read(___values);
    values = ___values.second;
    __inS.endReadParams();
    ::iBS::AMD_FcdcReadWriteService_SetDoublesColumnVectorPtr __cb = new IceAsync::iBS::AMD_FcdcReadWriteService_SetDoublesColumnVector(__inS);
    try
    {
        SetDoublesColumnVector_async(__cb, observerID, featureIdxFrom, featureIdxTo, values, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcReadWriteService::___SetBytesColumnVector(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerID;
    ::Ice::Long featureIdxFrom;
    ::Ice::Long featureIdxTo;
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> bytes;
    ::iBS::ByteArrayContentEnum content;
    ::iBS::ByteArrayEndianEnum endian;
    __is->read(observerID);
    __is->read(featureIdxFrom);
    __is->read(featureIdxTo);
    __is->read(bytes);
    __is->read(content);
    __is->read(endian);
    __inS.endReadParams();
    ::iBS::AMD_FcdcReadWriteService_SetBytesColumnVectorPtr __cb = new IceAsync::iBS::AMD_FcdcReadWriteService_SetBytesColumnVector(__inS);
    try
    {
        SetBytesColumnVector_async(__cb, observerID, featureIdxFrom, featureIdxTo, bytes, content, endian, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcReadWriteService::___SetIntsColumnVector(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerID;
    ::Ice::Long featureIdxFrom;
    ::Ice::Long featureIdxTo;
    ::std::pair<const ::Ice::Int*, const ::Ice::Int*> values;
    ::std::pair< ::IceUtil::ScopedArray< ::Ice::Int>, ::std::pair<const  ::Ice::Int*, const  ::Ice::Int*> > ___values;
    __is->read(observerID);
    __is->read(featureIdxFrom);
    __is->read(featureIdxTo);
    __is->read(___values);
    values = ___values.second;
    __inS.endReadParams();
    ::iBS::AMD_FcdcReadWriteService_SetIntsColumnVectorPtr __cb = new IceAsync::iBS::AMD_FcdcReadWriteService_SetIntsColumnVector(__inS);
    try
    {
        SetIntsColumnVector_async(__cb, observerID, featureIdxFrom, featureIdxTo, values, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcReadWriteService::___SetDoublesRowMatrix(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerGroupID;
    ::Ice::Long featureIdxFrom;
    ::Ice::Long featureIdxTo;
    ::std::pair<const ::Ice::Double*, const ::Ice::Double*> values;
    ::std::pair< ::IceUtil::ScopedArray< ::Ice::Double>, ::std::pair<const  ::Ice::Double*, const  ::Ice::Double*> > ___values;
    __is->read(observerGroupID);
    __is->read(featureIdxFrom);
    __is->read(featureIdxTo);
    __is->read(___values);
    values = ___values.second;
    __inS.endReadParams();
    ::iBS::AMD_FcdcReadWriteService_SetDoublesRowMatrixPtr __cb = new IceAsync::iBS::AMD_FcdcReadWriteService_SetDoublesRowMatrix(__inS);
    try
    {
        SetDoublesRowMatrix_async(__cb, observerGroupID, featureIdxFrom, featureIdxTo, values, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

namespace
{
const ::std::string __iBS__FcdcReadWriteService_all[] =
{
    "GetAMDTaskInfo",
    "GetDoublesColumnVector",
    "GetDoublesRowMatrix",
    "GetFeatureCntsByIntKeys",
    "GetFeatureDomains",
    "GetFeatureIdxsByIntKeys",
    "GetFeatureObservers",
    "GetFeatureValuePathPrefix",
    "GetFeatureValueStoreDir",
    "GetIntsColumnVector",
    "GetObserverIndex",
    "GetObserverStats",
    "GetObserversStats",
    "GetRowMatrix",
    "SampleRowMatrix",
    "SetBytesColumnVector",
    "SetDoublesColumnVector",
    "SetDoublesRowMatrix",
    "SetFeatureDomains",
    "SetFeatureObservers",
    "SetIntsColumnVector",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
iBS::FcdcReadWriteService::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__iBS__FcdcReadWriteService_all, __iBS__FcdcReadWriteService_all + 25, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __iBS__FcdcReadWriteService_all)
    {
        case 0:
        {
            return ___GetAMDTaskInfo(in, current);
        }
        case 1:
        {
            return ___GetDoublesColumnVector(in, current);
        }
        case 2:
        {
            return ___GetDoublesRowMatrix(in, current);
        }
        case 3:
        {
            return ___GetFeatureCntsByIntKeys(in, current);
        }
        case 4:
        {
            return ___GetFeatureDomains(in, current);
        }
        case 5:
        {
            return ___GetFeatureIdxsByIntKeys(in, current);
        }
        case 6:
        {
            return ___GetFeatureObservers(in, current);
        }
        case 7:
        {
            return ___GetFeatureValuePathPrefix(in, current);
        }
        case 8:
        {
            return ___GetFeatureValueStoreDir(in, current);
        }
        case 9:
        {
            return ___GetIntsColumnVector(in, current);
        }
        case 10:
        {
            return ___GetObserverIndex(in, current);
        }
        case 11:
        {
            return ___GetObserverStats(in, current);
        }
        case 12:
        {
            return ___GetObserversStats(in, current);
        }
        case 13:
        {
            return ___GetRowMatrix(in, current);
        }
        case 14:
        {
            return ___SampleRowMatrix(in, current);
        }
        case 15:
        {
            return ___SetBytesColumnVector(in, current);
        }
        case 16:
        {
            return ___SetDoublesColumnVector(in, current);
        }
        case 17:
        {
            return ___SetDoublesRowMatrix(in, current);
        }
        case 18:
        {
            return ___SetFeatureDomains(in, current);
        }
        case 19:
        {
            return ___SetFeatureObservers(in, current);
        }
        case 20:
        {
            return ___SetIntsColumnVector(in, current);
        }
        case 21:
        {
            return ___ice_id(in, current);
        }
        case 22:
        {
            return ___ice_ids(in, current);
        }
        case 23:
        {
            return ___ice_isA(in, current);
        }
        case 24:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
iBS::FcdcReadWriteService::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
iBS::FcdcReadWriteService::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
iBS::__patch(FcdcReadWriteServicePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::iBS::FcdcReadWriteServicePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::iBS::FcdcReadWriteService::ice_staticId(), v);
    }
}

::Ice::Object* iBS::upCast(::iBS::FcdcAdminService* p) { return p; }

namespace
{
const ::std::string __iBS__FcdcAdminService_ids[4] =
{
    "::Ice::Object",
    "::iBS::FcdcAdminService",
    "::iBS::FcdcReadService",
    "::iBS::FcdcReadWriteService"
};

}

bool
iBS::FcdcAdminService::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__iBS__FcdcAdminService_ids, __iBS__FcdcAdminService_ids + 4, _s);
}

::std::vector< ::std::string>
iBS::FcdcAdminService::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__iBS__FcdcAdminService_ids[0], &__iBS__FcdcAdminService_ids[4]);
}

const ::std::string&
iBS::FcdcAdminService::ice_id(const ::Ice::Current&) const
{
    return __iBS__FcdcAdminService_ids[1];
}

const ::std::string&
iBS::FcdcAdminService::ice_staticId()
{
    return __iBS__FcdcAdminService_ids[1];
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___Shutdown(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    Shutdown(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___RqstNewFeatureDomainID(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Ice::Int domainID;
    ::Ice::Int __ret = RqstNewFeatureDomainID(domainID, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(domainID);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___RqstNewFeatureObserverID(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    bool inRAMNoSave;
    __is->read(inRAMNoSave);
    __inS.endReadParams();
    ::Ice::Int observerID;
    ::Ice::Int __ret = RqstNewFeatureObserverID(inRAMNoSave, observerID, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(observerID);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___RqstNewFeatureObserversInGroup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int groupSize;
    bool inRAMNoSave;
    __is->read(groupSize);
    __is->read(inRAMNoSave);
    __inS.endReadParams();
    ::iBS::IntVec observerIDs;
    ::Ice::Int __ret = RqstNewFeatureObserversInGroup(groupSize, inRAMNoSave, observerIDs, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(observerIDs);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___AttachBigMatrix(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int colCnt;
    ::Ice::Long rowCnt;
    ::iBS::StringVec colNames;
    ::std::string storePathPrefix;
    __is->read(colCnt);
    __is->read(rowCnt);
    __is->read(colNames);
    __is->read(storePathPrefix);
    __inS.endReadParams();
    ::iBS::IntVec OIDs;
    try
    {
        ::Ice::Int __ret = AttachBigMatrix(colCnt, rowCnt, colNames, storePathPrefix, OIDs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(OIDs);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___AttachBigVector(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Long rowCnt;
    ::std::string colName;
    ::std::string storePathPrefix;
    __is->read(rowCnt);
    __is->read(colName);
    __is->read(storePathPrefix);
    __inS.endReadParams();
    ::Ice::Int OID;
    try
    {
        ::Ice::Int __ret = AttachBigVector(rowCnt, colName, storePathPrefix, OID, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(OID);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___ForceLoadInRAM(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec observerIDs;
    __is->read(observerIDs);
    __inS.endReadParams();
    ::iBS::AMD_FcdcAdminService_ForceLoadInRAMPtr __cb = new IceAsync::iBS::AMD_FcdcAdminService_ForceLoadInRAM(__inS);
    try
    {
        ForceLoadInRAM_async(__cb, observerIDs, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___ForceLeaveRAM(::IceInternal::Incoming& __inS, const ::Ice::Current& __current) const
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec observerIDs;
    __is->read(observerIDs);
    __inS.endReadParams();
    ::iBS::AMD_FcdcAdminService_ForceLeaveRAMPtr __cb = new IceAsync::iBS::AMD_FcdcAdminService_ForceLeaveRAM(__inS);
    try
    {
        ForceLeaveRAM_async(__cb, observerIDs, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___RecalculateObserverStats(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec observerIDs;
    __is->read(observerIDs);
    __inS.endReadParams();
    ::iBS::AMD_FcdcAdminService_RecalculateObserverStatsPtr __cb = new IceAsync::iBS::AMD_FcdcAdminService_RecalculateObserverStats(__inS);
    try
    {
        RecalculateObserverStats_async(__cb, observerIDs, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___RecalculateObserverIndex(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int observerID;
    bool saveIndexFile;
    __is->read(observerID);
    __is->read(saveIndexFile);
    __inS.endReadParams();
    ::iBS::AMD_FcdcAdminService_RecalculateObserverIndexPtr __cb = new IceAsync::iBS::AMD_FcdcAdminService_RecalculateObserverIndex(__inS);
    try
    {
        RecalculateObserverIndex_async(__cb, observerID, saveIndexFile, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___RemoveFeatureObservers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec observerIDs;
    bool removeDataFile;
    __is->read(observerIDs);
    __is->read(removeDataFile);
    __inS.endReadParams();
    ::iBS::AMD_FcdcAdminService_RemoveFeatureObserversPtr __cb = new IceAsync::iBS::AMD_FcdcAdminService_RemoveFeatureObservers(__inS);
    try
    {
        RemoveFeatureObservers_async(__cb, observerIDs, removeDataFile, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcAdminService::___SetObserverStats(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::ObserverStatsInfoVec osis;
    __is->read(osis);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = SetObserverStats(osis, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __iBS__FcdcAdminService_all[] =
{
    "AttachBigMatrix",
    "AttachBigVector",
    "ForceLeaveRAM",
    "ForceLoadInRAM",
    "GetAMDTaskInfo",
    "GetDoublesColumnVector",
    "GetDoublesRowMatrix",
    "GetFeatureCntsByIntKeys",
    "GetFeatureDomains",
    "GetFeatureIdxsByIntKeys",
    "GetFeatureObservers",
    "GetFeatureValuePathPrefix",
    "GetFeatureValueStoreDir",
    "GetIntsColumnVector",
    "GetObserverIndex",
    "GetObserverStats",
    "GetObserversStats",
    "GetRowMatrix",
    "RecalculateObserverIndex",
    "RecalculateObserverStats",
    "RemoveFeatureObservers",
    "RqstNewFeatureDomainID",
    "RqstNewFeatureObserverID",
    "RqstNewFeatureObserversInGroup",
    "SampleRowMatrix",
    "SetBytesColumnVector",
    "SetDoublesColumnVector",
    "SetDoublesRowMatrix",
    "SetFeatureDomains",
    "SetFeatureObservers",
    "SetIntsColumnVector",
    "SetObserverStats",
    "Shutdown",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
iBS::FcdcAdminService::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__iBS__FcdcAdminService_all, __iBS__FcdcAdminService_all + 37, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __iBS__FcdcAdminService_all)
    {
        case 0:
        {
            return ___AttachBigMatrix(in, current);
        }
        case 1:
        {
            return ___AttachBigVector(in, current);
        }
        case 2:
        {
            return ___ForceLeaveRAM(in, current);
        }
        case 3:
        {
            return ___ForceLoadInRAM(in, current);
        }
        case 4:
        {
            return ___GetAMDTaskInfo(in, current);
        }
        case 5:
        {
            return ___GetDoublesColumnVector(in, current);
        }
        case 6:
        {
            return ___GetDoublesRowMatrix(in, current);
        }
        case 7:
        {
            return ___GetFeatureCntsByIntKeys(in, current);
        }
        case 8:
        {
            return ___GetFeatureDomains(in, current);
        }
        case 9:
        {
            return ___GetFeatureIdxsByIntKeys(in, current);
        }
        case 10:
        {
            return ___GetFeatureObservers(in, current);
        }
        case 11:
        {
            return ___GetFeatureValuePathPrefix(in, current);
        }
        case 12:
        {
            return ___GetFeatureValueStoreDir(in, current);
        }
        case 13:
        {
            return ___GetIntsColumnVector(in, current);
        }
        case 14:
        {
            return ___GetObserverIndex(in, current);
        }
        case 15:
        {
            return ___GetObserverStats(in, current);
        }
        case 16:
        {
            return ___GetObserversStats(in, current);
        }
        case 17:
        {
            return ___GetRowMatrix(in, current);
        }
        case 18:
        {
            return ___RecalculateObserverIndex(in, current);
        }
        case 19:
        {
            return ___RecalculateObserverStats(in, current);
        }
        case 20:
        {
            return ___RemoveFeatureObservers(in, current);
        }
        case 21:
        {
            return ___RqstNewFeatureDomainID(in, current);
        }
        case 22:
        {
            return ___RqstNewFeatureObserverID(in, current);
        }
        case 23:
        {
            return ___RqstNewFeatureObserversInGroup(in, current);
        }
        case 24:
        {
            return ___SampleRowMatrix(in, current);
        }
        case 25:
        {
            return ___SetBytesColumnVector(in, current);
        }
        case 26:
        {
            return ___SetDoublesColumnVector(in, current);
        }
        case 27:
        {
            return ___SetDoublesRowMatrix(in, current);
        }
        case 28:
        {
            return ___SetFeatureDomains(in, current);
        }
        case 29:
        {
            return ___SetFeatureObservers(in, current);
        }
        case 30:
        {
            return ___SetIntsColumnVector(in, current);
        }
        case 31:
        {
            return ___SetObserverStats(in, current);
        }
        case 32:
        {
            return ___Shutdown(in, current);
        }
        case 33:
        {
            return ___ice_id(in, current);
        }
        case 34:
        {
            return ___ice_ids(in, current);
        }
        case 35:
        {
            return ___ice_isA(in, current);
        }
        case 36:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
iBS::FcdcAdminService::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
iBS::FcdcAdminService::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
iBS::__patch(FcdcAdminServicePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::iBS::FcdcAdminServicePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::iBS::FcdcAdminService::ice_staticId(), v);
    }
}

::Ice::Object* iBS::upCast(::iBS::FcdcRUVService* p) { return p; }

namespace
{
const ::std::string __iBS__FcdcRUVService_ids[3] =
{
    "::Ice::Object",
    "::iBS::FcdcRUVService",
    "::iBS::FcdcReadService"
};

}

bool
iBS::FcdcRUVService::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__iBS__FcdcRUVService_ids, __iBS__FcdcRUVService_ids + 3, _s);
}

::std::vector< ::std::string>
iBS::FcdcRUVService::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__iBS__FcdcRUVService_ids[0], &__iBS__FcdcRUVService_ids[3]);
}

const ::std::string&
iBS::FcdcRUVService::ice_id(const ::Ice::Current&) const
{
    return __iBS__FcdcRUVService_ids[1];
}

const ::std::string&
iBS::FcdcRUVService::ice_staticId()
{
    return __iBS__FcdcRUVService_ids[1];
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___SetActiveK(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int k;
    ::Ice::Int extW;
    __is->read(k);
    __is->read(extW);
    __inS.endReadParams();
    ::iBS::AMD_FcdcRUVService_SetActiveKPtr __cb = new IceAsync::iBS::AMD_FcdcRUVService_SetActiveK(__inS);
    try
    {
        SetActiveK_async(__cb, k, extW, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___SetOutputMode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::RUVOutputModeEnum mode;
    __is->read(mode);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = SetOutputMode(mode, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___SetOutputSamples(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec sampleIDs;
    __is->read(sampleIDs);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = SetOutputSamples(sampleIDs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___ExcludeSamplesForGroupMean(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec excludeSampleIDs;
    __is->read(excludeSampleIDs);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = ExcludeSamplesForGroupMean(excludeSampleIDs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___SetOutputScale(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::RUVOutputScaleEnum scale;
    __is->read(scale);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = SetOutputScale(scale, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___SetOutputWorkerNum(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int workerNum;
    __is->read(workerNum);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = SetOutputWorkerNum(workerNum, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___SetCtrlQuantileValues(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Double quantile;
    ::iBS::DoubleVec qvalues;
    ::Ice::Double fration;
    __is->read(quantile);
    __is->read(qvalues);
    __is->read(fration);
    __inS.endReadParams();
    ::Ice::Int __ret = SetCtrlQuantileValues(quantile, qvalues, fration, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___RebuildRUVModel(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int threadCnt;
    ::Ice::Long ramMb;
    __is->read(threadCnt);
    __is->read(ramMb);
    __inS.endReadParams();
    ::iBS::AMD_FcdcRUVService_RebuildRUVModelPtr __cb = new IceAsync::iBS::AMD_FcdcRUVService_RebuildRUVModel(__inS);
    try
    {
        RebuildRUVModel_async(__cb, threadCnt, ramMb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___GetConditionIdxs(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec observerIDs;
    __is->read(observerIDs);
    __inS.endReadParams();
    ::iBS::IntVec conditionIdxs;
    try
    {
        ::Ice::Int __ret = GetConditionIdxs(observerIDs, conditionIdxs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(conditionIdxs);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___GetConditionInfos(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::iBS::ConditionInfoVec conditions;
    try
    {
        ::Ice::Int __ret = GetConditionInfos(conditions, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(conditions);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___GetSamplesInGroups(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec sampleIDs;
    __is->read(sampleIDs);
    __inS.endReadParams();
    ::iBS::IntVecVec groupSampleIDs;
    try
    {
        ::Ice::Int __ret = GetSamplesInGroups(sampleIDs, groupSampleIDs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(groupSampleIDs);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___GetG(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::iBS::DoubleVec values;
    try
    {
        ::Ice::Int __ret = GetG(values, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(values);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___GetWt(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::iBS::DoubleVec values;
    try
    {
        ::Ice::Int __ret = GetWt(values, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(values);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___GetEigenVals(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::iBS::DoubleVec values;
    try
    {
        ::Ice::Int __ret = GetEigenVals(values, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(values);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___SelectKByEigenVals(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Double minFraction;
    __is->read(minFraction);
    __inS.endReadParams();
    ::Ice::Int k;
    ::iBS::DoubleVec fractions;
    try
    {
        ::Ice::Int __ret = SelectKByEigenVals(minFraction, k, fractions, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(k);
        __os->write(fractions);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___DecomposeVariance(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec ks;
    ::iBS::IntVec extWs;
    ::iBS::IntVecVec wtVecIdxs;
    ::Ice::Long featureIdxFrom;
    ::Ice::Long featureIdxTo;
    ::Ice::Int threadCnt;
    ::Ice::Long ramMb;
    ::std::string outfile;
    __is->read(ks);
    __is->read(extWs);
    __is->read(wtVecIdxs);
    __is->read(featureIdxFrom);
    __is->read(featureIdxTo);
    __is->read(threadCnt);
    __is->read(ramMb);
    __is->read(outfile);
    __inS.endReadParams();
    ::iBS::AMD_FcdcRUVService_DecomposeVariancePtr __cb = new IceAsync::iBS::AMD_FcdcRUVService_DecomposeVariance(__inS);
    try
    {
        DecomposeVariance_async(__cb, ks, extWs, wtVecIdxs, featureIdxFrom, featureIdxTo, threadCnt, ramMb, outfile, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

::Ice::DispatchStatus
iBS::FcdcRUVService::___SetWtVectorIdxs(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec vecIdxs;
    __is->read(vecIdxs);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = SetWtVectorIdxs(vecIdxs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __iBS__FcdcRUVService_all[] =
{
    "DecomposeVariance",
    "ExcludeSamplesForGroupMean",
    "GetAMDTaskInfo",
    "GetConditionIdxs",
    "GetConditionInfos",
    "GetDoublesColumnVector",
    "GetDoublesRowMatrix",
    "GetEigenVals",
    "GetFeatureCntsByIntKeys",
    "GetFeatureDomains",
    "GetFeatureIdxsByIntKeys",
    "GetFeatureObservers",
    "GetFeatureValuePathPrefix",
    "GetFeatureValueStoreDir",
    "GetG",
    "GetIntsColumnVector",
    "GetObserverIndex",
    "GetObserverStats",
    "GetObserversStats",
    "GetRowMatrix",
    "GetSamplesInGroups",
    "GetWt",
    "RebuildRUVModel",
    "SampleRowMatrix",
    "SelectKByEigenVals",
    "SetActiveK",
    "SetCtrlQuantileValues",
    "SetOutputMode",
    "SetOutputSamples",
    "SetOutputScale",
    "SetOutputWorkerNum",
    "SetWtVectorIdxs",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
iBS::FcdcRUVService::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__iBS__FcdcRUVService_all, __iBS__FcdcRUVService_all + 36, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __iBS__FcdcRUVService_all)
    {
        case 0:
        {
            return ___DecomposeVariance(in, current);
        }
        case 1:
        {
            return ___ExcludeSamplesForGroupMean(in, current);
        }
        case 2:
        {
            return ___GetAMDTaskInfo(in, current);
        }
        case 3:
        {
            return ___GetConditionIdxs(in, current);
        }
        case 4:
        {
            return ___GetConditionInfos(in, current);
        }
        case 5:
        {
            return ___GetDoublesColumnVector(in, current);
        }
        case 6:
        {
            return ___GetDoublesRowMatrix(in, current);
        }
        case 7:
        {
            return ___GetEigenVals(in, current);
        }
        case 8:
        {
            return ___GetFeatureCntsByIntKeys(in, current);
        }
        case 9:
        {
            return ___GetFeatureDomains(in, current);
        }
        case 10:
        {
            return ___GetFeatureIdxsByIntKeys(in, current);
        }
        case 11:
        {
            return ___GetFeatureObservers(in, current);
        }
        case 12:
        {
            return ___GetFeatureValuePathPrefix(in, current);
        }
        case 13:
        {
            return ___GetFeatureValueStoreDir(in, current);
        }
        case 14:
        {
            return ___GetG(in, current);
        }
        case 15:
        {
            return ___GetIntsColumnVector(in, current);
        }
        case 16:
        {
            return ___GetObserverIndex(in, current);
        }
        case 17:
        {
            return ___GetObserverStats(in, current);
        }
        case 18:
        {
            return ___GetObserversStats(in, current);
        }
        case 19:
        {
            return ___GetRowMatrix(in, current);
        }
        case 20:
        {
            return ___GetSamplesInGroups(in, current);
        }
        case 21:
        {
            return ___GetWt(in, current);
        }
        case 22:
        {
            return ___RebuildRUVModel(in, current);
        }
        case 23:
        {
            return ___SampleRowMatrix(in, current);
        }
        case 24:
        {
            return ___SelectKByEigenVals(in, current);
        }
        case 25:
        {
            return ___SetActiveK(in, current);
        }
        case 26:
        {
            return ___SetCtrlQuantileValues(in, current);
        }
        case 27:
        {
            return ___SetOutputMode(in, current);
        }
        case 28:
        {
            return ___SetOutputSamples(in, current);
        }
        case 29:
        {
            return ___SetOutputScale(in, current);
        }
        case 30:
        {
            return ___SetOutputWorkerNum(in, current);
        }
        case 31:
        {
            return ___SetWtVectorIdxs(in, current);
        }
        case 32:
        {
            return ___ice_id(in, current);
        }
        case 33:
        {
            return ___ice_ids(in, current);
        }
        case 34:
        {
            return ___ice_isA(in, current);
        }
        case 35:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
iBS::FcdcRUVService::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
iBS::FcdcRUVService::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
iBS::__patch(FcdcRUVServicePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::iBS::FcdcRUVServicePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::iBS::FcdcRUVService::ice_staticId(), v);
    }
}

::Ice::Object* iBS::upCast(::iBS::BigMatrixService* p) { return p; }

namespace
{
const ::std::string __iBS__BigMatrixService_ids[3] =
{
    "::Ice::Object",
    "::iBS::BigMatrixService",
    "::iBS::FcdcReadService"
};

}

bool
iBS::BigMatrixService::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__iBS__BigMatrixService_ids, __iBS__BigMatrixService_ids + 3, _s);
}

::std::vector< ::std::string>
iBS::BigMatrixService::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__iBS__BigMatrixService_ids[0], &__iBS__BigMatrixService_ids[3]);
}

const ::std::string&
iBS::BigMatrixService::ice_id(const ::Ice::Current&) const
{
    return __iBS__BigMatrixService_ids[1];
}

const ::std::string&
iBS::BigMatrixService::ice_staticId()
{
    return __iBS__BigMatrixService_ids[1];
}

::Ice::DispatchStatus
iBS::BigMatrixService::___SetOutputSamples(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::IntVec sampleIDs;
    __is->read(sampleIDs);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = SetOutputSamples(sampleIDs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::BigMatrixService::___SetRowAdjust(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::RowAdjustEnum rowAdjust;
    __is->read(rowAdjust);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = SetRowAdjust(rowAdjust, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::BigMatrixService::___RecalculateObserverStats(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Long ramMb;
    __is->read(ramMb);
    __inS.endReadParams();
    ::iBS::AMD_BigMatrixService_RecalculateObserverStatsPtr __cb = new IceAsync::iBS::AMD_BigMatrixService_RecalculateObserverStats(__inS);
    try
    {
        RecalculateObserverStats_async(__cb, ramMb, __current);
    }
    catch(const ::std::exception& __ex)
    {
        __cb->ice_exception(__ex);
    }
    catch(...)
    {
        __cb->ice_exception();
    }
    return ::Ice::DispatchAsync;
}

namespace
{
const ::std::string __iBS__BigMatrixService_all[] =
{
    "GetAMDTaskInfo",
    "GetDoublesColumnVector",
    "GetDoublesRowMatrix",
    "GetFeatureCntsByIntKeys",
    "GetFeatureDomains",
    "GetFeatureIdxsByIntKeys",
    "GetFeatureObservers",
    "GetFeatureValuePathPrefix",
    "GetFeatureValueStoreDir",
    "GetIntsColumnVector",
    "GetObserverIndex",
    "GetObserverStats",
    "GetObserversStats",
    "GetRowMatrix",
    "RecalculateObserverStats",
    "SampleRowMatrix",
    "SetOutputSamples",
    "SetRowAdjust",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
iBS::BigMatrixService::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__iBS__BigMatrixService_all, __iBS__BigMatrixService_all + 22, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __iBS__BigMatrixService_all)
    {
        case 0:
        {
            return ___GetAMDTaskInfo(in, current);
        }
        case 1:
        {
            return ___GetDoublesColumnVector(in, current);
        }
        case 2:
        {
            return ___GetDoublesRowMatrix(in, current);
        }
        case 3:
        {
            return ___GetFeatureCntsByIntKeys(in, current);
        }
        case 4:
        {
            return ___GetFeatureDomains(in, current);
        }
        case 5:
        {
            return ___GetFeatureIdxsByIntKeys(in, current);
        }
        case 6:
        {
            return ___GetFeatureObservers(in, current);
        }
        case 7:
        {
            return ___GetFeatureValuePathPrefix(in, current);
        }
        case 8:
        {
            return ___GetFeatureValueStoreDir(in, current);
        }
        case 9:
        {
            return ___GetIntsColumnVector(in, current);
        }
        case 10:
        {
            return ___GetObserverIndex(in, current);
        }
        case 11:
        {
            return ___GetObserverStats(in, current);
        }
        case 12:
        {
            return ___GetObserversStats(in, current);
        }
        case 13:
        {
            return ___GetRowMatrix(in, current);
        }
        case 14:
        {
            return ___RecalculateObserverStats(in, current);
        }
        case 15:
        {
            return ___SampleRowMatrix(in, current);
        }
        case 16:
        {
            return ___SetOutputSamples(in, current);
        }
        case 17:
        {
            return ___SetRowAdjust(in, current);
        }
        case 18:
        {
            return ___ice_id(in, current);
        }
        case 19:
        {
            return ___ice_ids(in, current);
        }
        case 20:
        {
            return ___ice_isA(in, current);
        }
        case 21:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
iBS::BigMatrixService::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
iBS::BigMatrixService::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
iBS::__patch(BigMatrixServicePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::iBS::BigMatrixServicePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::iBS::BigMatrixService::ice_staticId(), v);
    }
}

::Ice::Object* iBS::upCast(::iBS::FcdcFacetAdminService* p) { return p; }

namespace
{
const ::std::string __iBS__FcdcFacetAdminService_ids[2] =
{
    "::Ice::Object",
    "::iBS::FcdcFacetAdminService"
};

}

bool
iBS::FcdcFacetAdminService::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__iBS__FcdcFacetAdminService_ids, __iBS__FcdcFacetAdminService_ids + 2, _s);
}

::std::vector< ::std::string>
iBS::FcdcFacetAdminService::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__iBS__FcdcFacetAdminService_ids[0], &__iBS__FcdcFacetAdminService_ids[2]);
}

const ::std::string&
iBS::FcdcFacetAdminService::ice_id(const ::Ice::Current&) const
{
    return __iBS__FcdcFacetAdminService_ids[1];
}

const ::std::string&
iBS::FcdcFacetAdminService::ice_staticId()
{
    return __iBS__FcdcFacetAdminService_ids[1];
}

::Ice::DispatchStatus
iBS::FcdcFacetAdminService::___RqstNewRUVFacet(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::iBS::RUVFacetInfo rfi;
    try
    {
        ::Ice::Int __ret = RqstNewRUVFacet(rfi, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(rfi);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcFacetAdminService::___RemoveRUVFacet(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int facetID;
    __is->read(facetID);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = RemoveRUVFacet(facetID, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcFacetAdminService::___SetRUVFacetInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::iBS::RUVFacetInfo rfi;
    __is->read(rfi);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = SetRUVFacetInfo(rfi, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcFacetAdminService::___GetRUVFacetInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int facetID;
    __is->read(facetID);
    __inS.endReadParams();
    ::iBS::RUVFacetInfo rfi;
    try
    {
        ::Ice::Int __ret = GetRUVFacetInfo(facetID, rfi, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(rfi);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcFacetAdminService::___GetRUVFacet(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int facetID;
    __is->read(facetID);
    __inS.endReadParams();
    try
    {
        ::iBS::FcdcRUVServicePrx __ret = GetRUVFacet(facetID, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
iBS::FcdcFacetAdminService::___GetBigMatrixFacet(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int gid;
    __is->read(gid);
    __inS.endReadParams();
    try
    {
        ::iBS::BigMatrixServicePrx __ret = GetBigMatrixFacet(gid, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::iBS::ArgumentException& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __iBS__FcdcFacetAdminService_all[] =
{
    "GetBigMatrixFacet",
    "GetRUVFacet",
    "GetRUVFacetInfo",
    "RemoveRUVFacet",
    "RqstNewRUVFacet",
    "SetRUVFacetInfo",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
iBS::FcdcFacetAdminService::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__iBS__FcdcFacetAdminService_all, __iBS__FcdcFacetAdminService_all + 10, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __iBS__FcdcFacetAdminService_all)
    {
        case 0:
        {
            return ___GetBigMatrixFacet(in, current);
        }
        case 1:
        {
            return ___GetRUVFacet(in, current);
        }
        case 2:
        {
            return ___GetRUVFacetInfo(in, current);
        }
        case 3:
        {
            return ___RemoveRUVFacet(in, current);
        }
        case 4:
        {
            return ___RqstNewRUVFacet(in, current);
        }
        case 5:
        {
            return ___SetRUVFacetInfo(in, current);
        }
        case 6:
        {
            return ___ice_id(in, current);
        }
        case 7:
        {
            return ___ice_ids(in, current);
        }
        case 8:
        {
            return ___ice_isA(in, current);
        }
        case 9:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
iBS::FcdcFacetAdminService::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
iBS::FcdcFacetAdminService::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
iBS::__patch(FcdcFacetAdminServicePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::iBS::FcdcFacetAdminServicePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::iBS::FcdcFacetAdminService::ice_staticId(), v);
    }
}
